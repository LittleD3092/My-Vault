/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/pagerank.js/lib/index.js
var require_lib = __commonJS({
  "node_modules/pagerank.js/lib/index.js"(exports, module2) {
    "use strict";
    function forOwn(object, callback2) {
      if (typeof object === "object" && typeof callback2 === "function") {
        for (var key in object) {
          if (object.hasOwnProperty(key) === true) {
            if (callback2(key, object[key]) === false) {
              break;
            }
          }
        }
      }
    }
    module2.exports = function() {
      var self = {
        count: 0,
        edges: {},
        nodes: {}
      };
      self.link = function(source, target, weight) {
        if (isFinite(weight) !== true || weight === null) {
          weight = 1;
        }
        weight = parseFloat(weight);
        if (self.nodes.hasOwnProperty(source) !== true) {
          self.count++;
          self.nodes[source] = {
            weight: 0,
            outbound: 0
          };
        }
        self.nodes[source].outbound += weight;
        if (self.nodes.hasOwnProperty(target) !== true) {
          self.count++;
          self.nodes[target] = {
            weight: 0,
            outbound: 0
          };
        }
        if (self.edges.hasOwnProperty(source) !== true) {
          self.edges[source] = {};
        }
        if (self.edges[source].hasOwnProperty(target) !== true) {
          self.edges[source][target] = 0;
        }
        self.edges[source][target] += weight;
      };
      self.rank = function(alpha, epsilon, callback2) {
        var delta = 1, inverse = 1 / self.count;
        forOwn(self.edges, function(source) {
          if (self.nodes[source].outbound > 0) {
            forOwn(self.edges[source], function(target) {
              self.edges[source][target] /= self.nodes[source].outbound;
            });
          }
        });
        forOwn(self.nodes, function(key) {
          self.nodes[key].weight = inverse;
        });
        while (delta > epsilon) {
          var leak = 0, nodes = {};
          forOwn(self.nodes, function(key, value) {
            nodes[key] = value.weight;
            if (value.outbound === 0) {
              leak += value.weight;
            }
            self.nodes[key].weight = 0;
          });
          leak *= alpha;
          forOwn(self.nodes, function(source) {
            forOwn(self.edges[source], function(target, weight) {
              self.nodes[target].weight += alpha * nodes[source] * weight;
            });
            self.nodes[source].weight += (1 - alpha) * inverse + leak * inverse;
          });
          delta = 0;
          forOwn(self.nodes, function(key, value) {
            delta += Math.abs(value.weight - nodes[key]);
          });
        }
        forOwn(self.nodes, function(key) {
          return callback2(key, self.nodes[key].weight);
        });
      };
      self.reset = function() {
        self.count = 0;
        self.edges = {};
        self.nodes = {};
      };
      return self;
    }();
  }
});

// node_modules/vhtml/dist/vhtml.js
var require_vhtml = __commonJS({
  "node_modules/vhtml/dist/vhtml.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.vhtml = factory();
    })(exports, function() {
      "use strict";
      var emptyTags = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
      var esc = function esc2(str) {
        return String(str).replace(/[&<>"']/g, function(s) {
          return "&" + map3[s] + ";";
        });
      };
      var map3 = { "&": "amp", "<": "lt", ">": "gt", '"': "quot", "'": "apos" };
      var setInnerHTMLAttr = "dangerouslySetInnerHTML";
      var DOMAttributeNames = {
        className: "class",
        htmlFor: "for"
      };
      var sanitized = {};
      function h4(name, attrs) {
        var stack = [], s = "";
        attrs = attrs || {};
        for (var i = arguments.length; i-- > 2; ) {
          stack.push(arguments[i]);
        }
        if (typeof name === "function") {
          attrs.children = stack.reverse();
          return name(attrs);
        }
        if (name) {
          s += "<" + name;
          if (attrs)
            for (var _i in attrs) {
              if (attrs[_i] !== false && attrs[_i] != null && _i !== setInnerHTMLAttr) {
                s += " " + (DOMAttributeNames[_i] ? DOMAttributeNames[_i] : esc(_i)) + '="' + esc(attrs[_i]) + '"';
              }
            }
          s += ">";
        }
        if (emptyTags.indexOf(name) === -1) {
          if (attrs[setInnerHTMLAttr]) {
            s += attrs[setInnerHTMLAttr].__html;
          } else
            while (stack.length) {
              var child = stack.pop();
              if (child) {
                if (child.pop) {
                  for (var _i2 = child.length; _i2--; ) {
                    stack.push(child[_i2]);
                  }
                } else {
                  s += sanitized[child] === true ? child : esc(child);
                }
              }
            }
          s += name ? "</" + name + ">" : "";
        }
        sanitized[s] = true;
        return s;
      }
      return h4;
    });
  }
});

// src/main.ts
__export(exports, {
  default: () => SRPlugin
});
var import_obsidian8 = __toModule(require("obsidian"));
var graph = __toModule(require_lib());

// src/settings.tsx
var import_obsidian2 = __toModule(require("obsidian"));
var import_vhtml = __toModule(require_vhtml());

// src/lang/helpers.ts
var import_obsidian = __toModule(require("obsidian"));

// src/lang/locale/ar.ts
var ar_default = {};

// src/lang/locale/cz.ts
var cz_default = {
  DECKS: "Bal\xED\u010Dky",
  DUE_CARDS: "Karti\u010Dky po term\xEDnu",
  NEW_CARDS: "Nov\xE9 karti\u010Dky",
  TOTAL_CARDS: "Karti\u010Dek celkem",
  EDIT_LATER: "Upravit pozd\u011Bji",
  RESET_CARD_PROGRESS: "Vynulovat pokrok karti\u010Dky",
  HARD: "Te\u017Ek\xE9",
  GOOD: "Dobr\xE9",
  EASY: "Jednoduch\xE9",
  SHOW_ANSWER: "Uk\xE1zat odpov\u011B\u010F",
  CARD_PROGRESS_RESET: "Pokrok karti\u010Dky byl vynulov\xE1n.",
  OPEN_NOTE_FOR_REVIEW: "Otev\u0159\xEDt pozn\xE1mku k revizi",
  REVIEW_CARDS: "Pozn\xE1mek k revizi",
  REVIEW_EASY_FILE_MENU: "Revize: Jednoduch\xE9",
  REVIEW_GOOD_FILE_MENU: "Revize: Dobr\xE9",
  REVIEW_HARD_FILE_MENU: "Revize: T\u011B\u017Ek\xE9",
  REVIEW_NOTE_EASY_CMD: "Ozna\u010Dit pozn\xE1mku jako jednoduchou",
  REVIEW_NOTE_GOOD_CMD: "Ozna\u010Dit pozn\xE1mku jako dobrou",
  REVIEW_NOTE_HARD_CMD: "Ozna\u010Dit pozn\xE1mku jako te\u017Ekou",
  REVIEW_CARDS_IN_NOTE: "Revidovat karti\u010Dky v t\xE9to pozn\xE1mce.",
  CRAM_CARDS_IN_NOTE: "Cram karti\u010Dky v t\xE9to pozn\xE1mce.",
  REVIEW_ALL_CARDS: "Revidovat karti\u010Dky ve v\u0161ech pozn\xE1mk\xE1ch",
  VIEW_STATS: "Uk\xE1zat statistiky",
  STATUS_BAR: "Revize: ${dueNotesCount} pozn\xE1mek, ${dueFlashcardsCount} karti\u010Dek po term\xEDnu",
  SYNC_TIME_TAKEN: "Synchronizace trvala ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "Pozn\xE1mka je ulo\u017Eena v ignorovan\xE9 slo\u017Ece (zkontrolujte nastaven\xED).",
  PLEASE_TAG_NOTE: "Pros\xEDm ozna\u010Dne pozn\xE1mku odpov\xEDdaj\xEDc\xEDm tagem pro revizi (v nastaven\xED).",
  RESPONSE_RECEIVED: "Odpov\u011B\u010F p\u0159ijata.",
  NO_DECK_EXISTS: "Neexistuje \u017E\xE1dn\xFD bal\xED\u010Dek pro ${deckName}",
  ALL_CAUGHT_UP: "V\u0161e zrevidov\xE1no",
  DAYS_STR_IVL: "${interval} den/dn\xED",
  MONTHS_STR_IVL: "${interval} m\u011Bs\xEDc(\u016F)",
  YEARS_STR_IVL: "${interval} rok(\u016F)",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}r",
  SETTINGS_HEADER: "Spaced Repetition Plugin - Nastaven\xED",
  CHECK_WIKI: 'Pro v\xEDce informac\xED jd\u011Bte na <a href="${wiki_url}">wiki</a>.',
  FOLDERS_TO_IGNORE: "Ignorovan\xE9 slo\u017Eky",
  FOLDERS_TO_IGNORE_DESC: "Zadejte cesty ke slo\u017Ek\xE1m odd\u011Blen\xE9 od\u0159\xE1dkov\xE1n\xEDm nap\u0159\xEDkad. \u0160ablony Meta/Scripts",
  FLASHCARDS: "Karti\u010Dky",
  FLASHCARD_TAGS: "Tag pro karti\u010Dky",
  FLASHCARD_TAGS_DESC: "Zadete tagy ood\u011Blen\xE9 mezerou nebo od\u0159\xE1dkov\xE1n\xEDm nap\u0159\xEDklad. #karti\u010Dky #bal\xED\u010Dke2 #bal\xED\u010Dek3.",
  CONVERT_FOLDERS_TO_DECKS: "P\u0159ev\xE9st slo\u017Eky na bal\xED\u010Dky a podbal\xED\u010Dky?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "Toto je alternativa k tag\u016Fm karti\u010Dek viz nastaven\xED v\xFD\u0161e.",
  INLINE_SCHEDULING_COMMENTS: "Ulo\u017Eit pl\xE1novac\xED koment\xE1\u0159 na stejn\xFD \u0159\xE1dek jako posledn\xED polo\u017Eka karti\u010Dky?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Zapnut\xED t\xE9to volby zp\u016Fsob\xED, \u017Ee HTML koment\xE1\u0159e nebudou rozb\xEDjet form\xE1tov\xE1n\xED list\u016F.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Odlo\u017Eit p\u0159\xEDbuzn\xE9 karti\u010Dky na dal\u0161\xED den?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "P\u0159\xEDbuzn\xE9 karti\u010Dky jsou karti\u010Dky generovan\xE9 z textu stejn\xE9 pozn\xE1mky nap\u0159\xEDklad cloze smaz\xE1n\xED",
  SHOW_CARD_CONTEXT: "Uk\xE1zat kontext v karti\u010Dce?",
  SHOW_CARD_CONTEXT_DESC: "nap\u0159\xEDklad Titulek > Nadpis1 > Podnadpis > ... > Podnadpis",
  CARD_MODAL_HEIGHT_PERCENT: "V\xFD\u0161ka karti\u010Dek v procentech",
  CARD_MODAL_SIZE_PERCENT_DESC: "M\u011Blo by b\xFDt nastaveno na 100% na mobilu nebo kdy\u017E pou\u017E\xEDv\xE1te velk\xE9 obr\xE1zky",
  RESET_DEFAULT: "Resetovat v\xFDchoz\xED nastaven\xED",
  CARD_MODAL_WIDTH_PERCENT: "\u0160\xED\u0159ka karti\u010Dek v procentech",
  FILENAME_OR_OPEN_FILE: "Zobrazit jm\xE9no souboru m\xEDsto 'Zm\u011Bnit pozd\u011Bji' v revizi karti\u010Dky?",
  RANDOMIZE_CARD_ORDER: "N\xE1hodn\u011B zm\u011Bnit po\u0159ad\xED karti\u010Dek b\u011Bhem revize?",
  DISABLE_CLOZE_CARDS: "Vypnout cloze karti\u010Dky?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "P\u0159ev\xE9st ==zv\xFDrazn\u011Bn\xED== na clozes?",
  CONVERT_BOLD_TEXT_TO_CLOZES: "P\u0159ev\xE9st **tu\u010Dn\xFD text** na clozes?",
  INLINE_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro inline karti\u010Dky",
  FIX_SEPARATORS_MANUALLY_WARNING: "Pozor. Jakmile toto zm\u011Bn\xEDte, budete muset ru\u010Dn\u011B upravit v\u0161echny existuj\xEDc\xED karti\u010Dky.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro oto\u010Den\xE9 inline karti\u010Dky",
  MULTILINE_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro v\xEDce\u0159\xE1dkov\xE9 karti\u010Dky",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro v\xEDce\u0159\xE1dkove oto\u010Den\xE9 karti\u010Dky",
  NOTES: "Pozn\xE1mky",
  TAGS_TO_REVIEW: "Tag pro revizi",
  TAGS_TO_REVIEW_DESC: "Zadejte tagy odd\u011Blen\xE9 mezerami nebo od\u0159\xE1dkov\xE1n\xEDm nap\u0159\xEDklad #review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "Otev\u0159\xEDt n\xE1hodnou pozn\xE1mku pro revizi",
  OPEN_RANDOM_NOTE_DESC: "Pokud toto vypnete, pozn\xE1mky budou \u0159azeny dle d\u016Fle\u017Eitosti (PageRank).",
  AUTO_NEXT_NOTE: "Otev\u0159\xEDt automaticky dal\u0161\xED pozn\xE1mku po dokon\u010Den\xED revize",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "Vypnout volby revize v menu souboru nap\u0159\xEDklad 'Revize: Jednoduch\xE9'",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "Po vypnut\xED m\u016F\u017Eete pou\u017E\xEDvat kl\xE1vesov\xE9 zkratky. Restartujte Obsidian po zm\u011Bn\u011B nastaven\xED.",
  MAX_N_DAYS_REVIEW_QUEUE: "Maxim\xE1ln\xED po\u010Det dn\xED zobrazen\xFDch v prav\xE9m panelu",
  MIN_ONE_DAY: "Po\u010Det dn\xED mus\xED b\xFDt minim\xE1ln\u011B 1.",
  VALID_NUMBER_WARNING: "Pros\xEDm zadejte validn\xED \u010D\xEDslo.",
  ALGORITHM: "Algoritmus",
  CHECK_ALGORITHM_WIKI: 'Pro v\xEDce informac\xED jd\u011Bte na <a href="${algo_url}">popis algoritmu</a>.',
  BASE_EASE: "Z\xE1kladn\xED slo\u017Eitost",
  BASE_EASE_DESC: "minimum = 130, nejl\xE9pe p\u0159ibli\u017En\u011B 250.",
  BASE_EASE_MIN_WARNING: "Z\xE1kladn\xED slo\u017Eitost mus\xED b\xFDt minim\xE1ln\u011B 130.",
  LAPSE_INTERVAL_CHANGE: "Zm\u011Bna intervalu pokud karti\u010Dku/pozn\xE1mku ozna\u010D\xEDte jako slo\u017Eitou",
  LAPSE_INTERVAL_CHANGE_DESC: "nov\xFD_inteval = star\xFD_interval * zm\u011Bna_intevalu / 100.",
  EASY_BONUS: "Bonus pro jednoduch\xE9",
  EASY_BONUS_DESC: "Tento bonus umo\u017E\u0148uje nastavit rozd\xEDl intervalu mezi jednoduch\xFDmi a dobr\xFDmi karti\u010Dkami/pozn\xE1mkami (minimum = 100%).",
  EASY_BONUS_MIN_WARNING: "Bonus pro jednoduchost mus\xED b\xFDt minim\xE1ln\u011B 100.",
  MAX_INTERVAL: "Maxim\xE1ln\xED interval",
  MAX_INTERVAL_DESC: "Umo\u017E\u0148uje nastavit horn\xED limit pro interval (defaultn\u011B = 100 let).",
  MAX_INTERVAL_MIN_WARNING: "Maxim\xE1ln\xED interval mus\xED b\xFDt alespo\u0148 1 den.",
  MAX_LINK_CONTRIB: "Maxim\xE1ln\xED p\u0159\xEDsp\u011Bv\u011Bk prolinkov\xE1n\xED",
  MAX_LINK_CONTRIB_DESC: "Maxim\xE1ln\xED p\u0159\xEDsp\u011Bvek v\xE1\u017Een\xE9 slo\u017Eitosti prolinkovan\xFDch pozn\xE1mek pou\u017Eit\xFD pro ur\u010Den\xED po\u010D\xE1te\u010Dn\xED slo\u017Eitosti.",
  LOGGING: "Zaznamen\xE1v\xE1m",
  DISPLAY_DEBUG_INFO: "Zobrazit informace pro lad\u011Bn\xED na v\xFDvoj\xE1\u0159sk\xE9 konzoli?",
  NOTES_REVIEW_QUEUE: "Fronta pozn\xE1mek k revizi",
  CLOSE: "Uzav\u0159en\xE9",
  NEW: "Nov\xE9",
  YESTERDAY: "V\u010Dera",
  TODAY: "Dnes",
  TOMORROW: "Z\xEDtra",
  STATS_TITLE: "Statistiky",
  MONTH: "M\u011Bs\xEDc",
  QUARTER: "\u010Ctvrtlet\xED",
  YEAR: "Rok",
  LIFETIME: "Celkov\u011B",
  FORECAST: "P\u0159edpov\u011B\u010F",
  FORECAST_DESC: "Celkov\xFD po\u010Det karti\u010Dek, kter\xFDm vypr\u0161\xED term\xEDn",
  SCHEDULED: "Napl\xE1nov\xE1no",
  DAYS: "Dn\xED",
  NUMBER_OF_CARDS: "Po\u010Det karti\u010Dek",
  REVIEWS_PER_DAY: "Pr\u016Fm\u011Br: ${avg} revize/den",
  INTERVALS: "Intervaly",
  INTERVALS_DESC: "Doba, za kterou bude znovu zobrazeno k revize",
  COUNT: "Po\u010Det",
  INTERVALS_SUMMARY: "Pr\u016Fm\u011Brn\xFD interval: ${avg}, Nejdel\u0161\xED interval: ${longest}",
  EASES: "Slo\u017Eitost",
  EASES_SUMMARY: "Pr\u016Fm\u011Brn\xE1 slo\u017Eitost: ${avgEase}",
  CARD_TYPES: "Typy karti\u010Dek",
  CARD_TYPES_DESC: "Obsahuje i odlo\u017Een\xE9 karti\u010Dky (pokud existuj\xED)",
  CARD_TYPE_NEW: "Nov\xE1",
  CARD_TYPE_YOUNG: "Mlad\xE1",
  CARD_TYPE_MATURE: "Dosp\u011Bl\xE1",
  CARD_TYPES_SUMMARY: "Karti\u010Dek celkem: ${totalCardsCount}"
};

// src/lang/locale/da.ts
var da_default = {};

// src/lang/locale/de.ts
var de_default = {
  DECKS: "Stapel",
  DUE_CARDS: "Anstehende Karten",
  NEW_CARDS: "Neue Karten",
  TOTAL_CARDS: "Alle Karten",
  EDIT_LATER: "Sp\xE4ter bearbeiten",
  RESET_CARD_PROGRESS: "Kartenfortschritt zur\xFCcksetzten",
  HARD: "Schwer",
  GOOD: "Gut",
  EASY: "Einfach",
  SHOW_ANSWER: "Zeige Antwort",
  CARD_PROGRESS_RESET: "Kartenfortschritt wurde zur\xFCckgesetzt.",
  OPEN_NOTE_FOR_REVIEW: "Notiz zur Wiederholung \xF6ffnen",
  REVIEW_CARDS: "Lernkarten wiederholen",
  REVIEW_EASY_FILE_MENU: "Notiz abschliessen als: Einfach",
  REVIEW_GOOD_FILE_MENU: "Notiz abschliessen als: Gut",
  REVIEW_HARD_FILE_MENU: "Notiz abschliessen als: Schwer",
  REVIEW_NOTE_EASY_CMD: "Notiz abschliessen als: Einfach",
  REVIEW_NOTE_GOOD_CMD: "Notiz abschliessen als: Gut",
  REVIEW_NOTE_HARD_CMD: "Notiz abschliessen als: Schwer",
  REVIEW_CARDS_IN_NOTE: "Lernkarten in dieser Notiz wiederholen",
  CRAM_CARDS_IN_NOTE: "Lernkarten in dieser Notiz pauken.",
  REVIEW_ALL_CARDS: "Alle Lernkarten wiederholen",
  VIEW_STATS: "Statistiken anzeigen",
  STATUS_BAR: "Wiederholung: ${dueNotesCount} Notiz(en), ${dueFlashcardsCount} Karte(n) anstehend",
  SYNC_TIME_TAKEN: "Sync dauerte ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "Notiz befindet sich in einem ausgeschlossenen Ordner (siehe Einstellungen).",
  PLEASE_TAG_NOTE: "Bitte die Notiz f\xFCr Wiederholungen entsprechend taggen (siehe Einstellungen).",
  RESPONSE_RECEIVED: "Antwort erhalten.",
  NO_DECK_EXISTS: "Kein Stapel f\xFCr ${deckName} gefunden.",
  ALL_CAUGHT_UP: "Yuhu! Alles geschafft! :D.",
  DAYS_STR_IVL: "${interval} Tag(e)",
  MONTHS_STR_IVL: "${interval} Monat(e)",
  YEARS_STR_IVL: "${interval} Jahr(e)",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}y",
  SETTINGS_HEADER: "Spaced Repetition Plugin - Einstellungen",
  CHECK_WIKI: 'Weitere Informationen gibt es im <a href="${wiki_url}">Wiki</a> (english).',
  FOLDERS_TO_IGNORE: "Ausgeschlossene Ordner",
  FOLDERS_TO_IGNORE_DESC: "Mehrere Ordner mit Zeilenumbr\xFCchen getrennt angeben. Bsp. OrdnerA[Zeilenumbruch]OrdnerB/Unterordner",
  FLASHCARDS: "Lernkarten",
  FLASHCARD_TAGS: "Lernkarten Tags",
  FLASHCARD_TAGS_DESC: "Mehrere Tags mit Leerzeichen oder Zeilenumbr\xFCchen getrennt angeben. Bsp. #karte #stapel2 #stapel3.",
  CONVERT_FOLDERS_TO_DECKS: "Ordner in Stapel und Substapel umwandeln?",
  CONVERT_FOLDERS_TO_DECKS_DESC: 'Eine Alternative zur oberen "Lernkarten Tags" Option.',
  INLINE_SCHEDULING_COMMENTS: "Den Fortschritt in der gleichen Zeile wie die letzte Zeile einer Lernkartei speichern?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Wenn aktiviert, wird der HTML Kommentar die umgebende Liste nicht aufbrechen.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Verwandte Karten auf den n\xE4chsten Tag verlegen?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Verwandte Karten sind aus der gleichen Karte generiert worden (z.B. L\xFCckentextkarten oder beidseitige Karten).",
  SHOW_CARD_CONTEXT: "Kontext in den Karten anzeigen?",
  SHOW_CARD_CONTEXT_DESC: "Bsp. Titel > \xDCberschrift 1 > Sektion > ... > Untersektion",
  CARD_MODAL_HEIGHT_PERCENT: "H\xF6he der Lernkartei in Prozent",
  CARD_MODAL_SIZE_PERCENT_DESC: "Auf kleinen Bildschirmen (z.B. Smartphones) oder bei sehr grossen Bildern sollte dieser Wert auf 100% gesetzt werden.",
  RESET_DEFAULT: "Standardeinstellung wiederherstellen",
  CARD_MODAL_WIDTH_PERCENT: "Breite einer Lernkarte in Prozent",
  FILENAME_OR_OPEN_FILE: "W\xE4hrend der Wiederholung den Notiznamen statt 'Sp\xE4ter bearbeiten' anzeigen?",
  RANDOMIZE_CARD_ORDER: "W\xE4hrend der Wiederhoung die Reihenfolge zuf\xE4llig mischen?",
  DISABLE_CLOZE_CARDS: "L\xFCckentextkarten (cloze deletions) deaktivieren?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "==Hervorgehobenen== Text in L\xFCckentextkarten umwandeln?",
  CONVERT_BOLD_TEXT_TO_CLOZES: "**Fettgedruckten** Text in L\xFCckentextkarten umwandeln?",
  INLINE_CARDS_SEPARATOR: "Trennzeichen f\xFCr einzeilige Lernkarten",
  FIX_SEPARATORS_MANUALLY_WARNING: "Wenn diese Einstellung ge\xE4ndert wird, dann m\xFCssen die entsprechenden Lernkarten manuell angepasst werden.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Trennzeichen f\xFCr einzeilige beidseitige Lernkarten",
  MULTILINE_CARDS_SEPARATOR: "Trennzeichen f\xFCr mehrzeilige Lernkarten",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Trennzeichen f\xFCr mehrzeilige beidseitige Lernkarten",
  NOTES: "Notizen",
  TAGS_TO_REVIEW: "Zu wiederholende Tags",
  TAGS_TO_REVIEW_DESC: "Mehrere Tags k\xF6nnen mit Leerzeichen oder Zeilenumbr\xFCchen getrennt angegeben werden. Bsp. #karte #tag1 #tag2.",
  OPEN_RANDOM_NOTE: "Zuf\xE4llige Karten wiederholen",
  OPEN_RANDOM_NOTE_DESC: "Wenn dies deaktiviert wird, dann werden die Notizen nach Wichtigkeit wiederholt (PageRank).",
  AUTO_NEXT_NOTE: "Nach einer Wiederholung automatisch die n\xE4chste Karte \xF6ffnen",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "Optionen zur Wiederholung im Men\xFC einer Datei deaktivieren. Bsp. Wiederholen: Einfach Gut Schwer",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "Nach dem Deaktivieren k\xF6nnen die Tastenk\xFCrzel zur Wiederholung verwendet werden. Obsidian muss nach einer \xC4nderung neu geladen weren.",
  MAX_N_DAYS_REVIEW_QUEUE: "Maximale Anzahl anstehender Notizen, die im rechten Fensterbereich angezeigt werden",
  MIN_ONE_DAY: "Anzahl der Tage muss mindestens 1 sein.",
  VALID_NUMBER_WARNING: "Bitte eine g\xFCltige Zahl eingeben.",
  ALGORITHM: "Algorithmus",
  CHECK_ALGORITHM_WIKI: 'Weiterf\xFChrende Informationen: <a href="${algo_url}">Implementierung des Algorithmus</a> (english).',
  BASE_EASE: "Basis der Einfachheit",
  BASE_EASE_DESC: "Minimum ist 130. Empfohlen wird ca. 250.",
  BASE_EASE_MIN_WARNING: "Basis der Einfachheit muss mindestens 130 sein.",
  LAPSE_INTERVAL_CHANGE: "Anpassungsfaktor des Intervalls wenn eine Notiz / Karte 'Schwer' abgeschlossen wird",
  LAPSE_INTERVAL_CHANGE_DESC: "neuesIntervall = altesIntervall * anpassungsfaktor / 100.",
  EASY_BONUS: "Einfachheit-Bonus",
  EASY_BONUS_DESC: "Der Einfachheit-Bonus gibt an um welchen Faktor (in Prozent) das Intervall l\xE4nger sein soll, wenn eine Notiz / Karte 'Einfach' statt 'Gut' abgeschlossen wird. Minimum ist 100%.",
  EASY_BONUS_MIN_WARNING: "Der Einfachheit-Bonus muss mindestens 100 sein.",
  MAX_INTERVAL: "Maximales Intervall",
  MAX_INTERVAL_DESC: "Das maximale Intervall (in Tagen) f\xFCr Wiederholungen. Standard sind 100 Jahre.",
  MAX_INTERVAL_MIN_WARNING: "Das maximale Interall muss mindestens ein Tag sein.",
  MAX_LINK_CONTRIB: "Maximaler Einfluss von Links",
  MAX_LINK_CONTRIB_DESC: "Maximaler Einfluss der Einfachheiten verlinkter Notizen zur gewichteten initialen Einfachheit einer neuen Lernkarte.",
  LOGGING: "Logging",
  DISPLAY_DEBUG_INFO: "Informationen zum Debugging in der Entwicklerkonsole anzeigen?",
  NOTES_REVIEW_QUEUE: "Anstehende Notizen zur Wiederholung",
  CLOSE: "Schliessen",
  NEW: "Neu",
  YESTERDAY: "Gestern",
  TODAY: "Heute",
  TOMORROW: "Morgen",
  STATS_TITLE: "Statistiken",
  MONTH: "Month",
  QUARTER: "Quarter",
  YEAR: "Year",
  LIFETIME: "Lifetime",
  FORECAST: "Prognose",
  FORECAST_DESC: "Anzahl der k\xFCnftig anstehenden Karten",
  SCHEDULED: "Anstehend",
  DAYS: "Tage",
  NUMBER_OF_CARDS: "Anzahl der Karten",
  REVIEWS_PER_DAY: "Durchschnitt: ${avg} Wiederholungen/Tag",
  INTERVALS: "Intervalle",
  INTERVALS_DESC: "Intervalle bis Wiederholungen anstehen",
  COUNT: "Anzahl",
  INTERVALS_SUMMARY: "Durchschnittliches Intervall: ${avg}, L\xE4ngstes Intervall: ${longest}",
  EASES: "Einfachheit",
  EASES_SUMMARY: "Durchschnittliche Einfachheit: ${avgEase}",
  CARD_TYPES: "Kategorisierung",
  CARD_TYPES_DESC: "Verlegte Karten eingeschlossen",
  CARD_TYPE_NEW: "Neu",
  CARD_TYPE_YOUNG: "Jung",
  CARD_TYPE_MATURE: "Ausgereift",
  CARD_TYPES_SUMMARY: "Insgesamt ${totalCardsCount} Karten"
};

// src/lang/locale/en.ts
var en_default = {
  DECKS: "Decks",
  DUE_CARDS: "Due Cards",
  NEW_CARDS: "New Cards",
  TOTAL_CARDS: "Total Cards",
  EDIT_LATER: "Edit Later",
  RESET_CARD_PROGRESS: "Reset card's progress",
  HARD: "Hard",
  GOOD: "Good",
  EASY: "Easy",
  SHOW_ANSWER: "Show Answer",
  CARD_PROGRESS_RESET: "Card's progress has been reset.",
  OPEN_NOTE_FOR_REVIEW: "Open a note for review",
  REVIEW_CARDS: "Review flashcards",
  REVIEW_EASY_FILE_MENU: "Review: Easy",
  REVIEW_GOOD_FILE_MENU: "Review: Good",
  REVIEW_HARD_FILE_MENU: "Review: Hard",
  REVIEW_NOTE_EASY_CMD: "Review note as easy",
  REVIEW_NOTE_GOOD_CMD: "Review note as good",
  REVIEW_NOTE_HARD_CMD: "Review note as hard",
  REVIEW_CARDS_IN_NOTE: "Review flashcards in this note",
  CRAM_CARDS_IN_NOTE: "Cram flashcards in this note.",
  REVIEW_ALL_CARDS: "Review flashcards from all notes",
  VIEW_STATS: "View statistics",
  STATUS_BAR: "Review: ${dueNotesCount} note(s), ${dueFlashcardsCount} card(s) due",
  SYNC_TIME_TAKEN: "Sync took ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "Note is saved under ignored folder (check settings).",
  PLEASE_TAG_NOTE: "Please tag the note appropriately for reviewing (in settings).",
  RESPONSE_RECEIVED: "Response received.",
  NO_DECK_EXISTS: "No deck exists for ${deckName}",
  ALL_CAUGHT_UP: "You're all caught up now :D.",
  DAYS_STR_IVL: "${interval} day(s)",
  MONTHS_STR_IVL: "${interval} month(s)",
  YEARS_STR_IVL: "${interval} year(s)",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}y",
  SETTINGS_HEADER: "Spaced Repetition Plugin - Settings",
  CHECK_WIKI: 'For more information, check the <a href="${wiki_url}">wiki</a>.',
  FOLDERS_TO_IGNORE: "Folders to ignore",
  FOLDERS_TO_IGNORE_DESC: "Enter folder paths separated by newlines i.e. Templates Meta/Scripts",
  FLASHCARDS: "Flashcards",
  FLASHCARD_TAGS: "Flashcard tags",
  FLASHCARD_TAGS_DESC: "Enter tags separated by spaces or newlines i.e. #flashcards #deck2 #deck3.",
  CONVERT_FOLDERS_TO_DECKS: "Convert folders to decks and subdecks?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "This is an alternative to the Flashcard tags option above.",
  INLINE_SCHEDULING_COMMENTS: "Save scheduling comment on the same line as the flashcard's last line?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Turning this on will make the HTML comments not break list formatting.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Bury sibling cards until the next day?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Siblings are cards generated from the same card text i.e. cloze deletions",
  SHOW_CARD_CONTEXT: "Show context in cards?",
  SHOW_CARD_CONTEXT_DESC: "i.e. Title > Heading 1 > Subheading > ... > Subheading",
  CARD_MODAL_HEIGHT_PERCENT: "Flashcard Height Percentage",
  CARD_MODAL_SIZE_PERCENT_DESC: "Should be set to 100% on mobile or if you have very large images",
  RESET_DEFAULT: "Reset to default",
  CARD_MODAL_WIDTH_PERCENT: "Flashcard Width Percentage",
  FILENAME_OR_OPEN_FILE: "Show file name instead of 'Edit Later' in flashcard review?",
  RANDOMIZE_CARD_ORDER: "Randomize card order during review?",
  DISABLE_CLOZE_CARDS: "Disable cloze cards?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "Convert ==hightlights== to clozes?",
  CONVERT_BOLD_TEXT_TO_CLOZES: "Convert **bolded text** to clozes?",
  INLINE_CARDS_SEPARATOR: "Separator for inline flashcards",
  FIX_SEPARATORS_MANUALLY_WARNING: "Note that after changing this you have to manually edit any flashcards you already have.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Separator for inline reversed flashcards",
  MULTILINE_CARDS_SEPARATOR: "Separator for multiline flashcards",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Separator for multiline reversed flashcards",
  NOTES: "Notes",
  TAGS_TO_REVIEW: "Tags to review",
  TAGS_TO_REVIEW_DESC: "Enter tags separated by spaces or newlines i.e. #review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "Open a random note for review",
  OPEN_RANDOM_NOTE_DESC: "When you turn this off, notes are ordered by importance (PageRank).",
  AUTO_NEXT_NOTE: "Open next note automatically after a review",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "Disable review options in the file menu i.e. Review: Easy Good Hard",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "After disabling, you can review using the command hotkeys. Reload Obsidian after changing this.",
  MAX_N_DAYS_REVIEW_QUEUE: "Maximum number of days to display on right panel",
  MIN_ONE_DAY: "The number of days must be at least 1.",
  VALID_NUMBER_WARNING: "Please provide a valid number.",
  ALGORITHM: "Algorithm",
  CHECK_ALGORITHM_WIKI: 'For more information, check the <a href="${algo_url}">algorithm implementation</a>.',
  BASE_EASE: "Base ease",
  BASE_EASE_DESC: "minimum = 130, preferrably approximately 250.",
  BASE_EASE_MIN_WARNING: "The base ease must be at least 130.",
  LAPSE_INTERVAL_CHANGE: "Interval change when you review a flashcard/note as hard",
  LAPSE_INTERVAL_CHANGE_DESC: "newInterval = oldInterval * intervalChange / 100.",
  EASY_BONUS: "Easy Bonus",
  EASY_BONUS_DESC: "The easy bonus allows you to set the difference in intervals between answering Good and Easy on a flashcard/note (minimum = 100%).",
  EASY_BONUS_MIN_WARNING: "The easy bonus must be at least 100.",
  MAX_INTERVAL: "Maximum Interval",
  MAX_INTERVAL_DESC: "Allows you to place an upper limit on the interval (default = 100 years).",
  MAX_INTERVAL_MIN_WARNING: "The maximum interval must be at least 1 day.",
  MAX_LINK_CONTRIB: "Maximum link contribution",
  MAX_LINK_CONTRIB_DESC: "Maximum contribution of the weighted ease of linked notes to the initial ease.",
  LOGGING: "Logging",
  DISPLAY_DEBUG_INFO: "Display debugging information on the developer console?",
  NOTES_REVIEW_QUEUE: "Notes Review Queue",
  CLOSE: "Close",
  NEW: "New",
  YESTERDAY: "Yesterday",
  TODAY: "Today",
  TOMORROW: "Tomorrow",
  STATS_TITLE: "Statistics",
  MONTH: "Month",
  QUARTER: "Quarter",
  YEAR: "Year",
  LIFETIME: "Lifetime",
  FORECAST: "Forecast",
  FORECAST_DESC: "The number of cards due in the future",
  SCHEDULED: "Scheduled",
  DAYS: "Days",
  NUMBER_OF_CARDS: "Number of cards",
  REVIEWS_PER_DAY: "Average: ${avg} reviews/day",
  INTERVALS: "Intervals",
  INTERVALS_DESC: "Delays until reviews are shown again",
  COUNT: "Count",
  INTERVALS_SUMMARY: "Average interval: ${avg}, Longest interval: ${longest}",
  EASES: "Eases",
  EASES_SUMMARY: "Average ease: ${avgEase}",
  CARD_TYPES: "Card Types",
  CARD_TYPES_DESC: "This includes buried cards as well, if any",
  CARD_TYPE_NEW: "New",
  CARD_TYPE_YOUNG: "Young",
  CARD_TYPE_MATURE: "Mature",
  CARD_TYPES_SUMMARY: "Total cards: ${totalCardsCount}"
};

// src/lang/locale/en-gb.ts
var en_gb_default = {};

// src/lang/locale/es.ts
var es_default = {};

// src/lang/locale/fr.ts
var fr_default = {};

// src/lang/locale/hi.ts
var hi_default = {};

// src/lang/locale/id.ts
var id_default = {};

// src/lang/locale/it.ts
var it_default = {};

// src/lang/locale/ja.ts
var ja_default = {
  DECKS: "\u30C7\u30C3\u30AD",
  DUE_CARDS: "\u671F\u65E5\u306E\u30AB\u30FC\u30C9",
  NEW_CARDS: "\u65B0\u898F\u306E\u30AB\u30FC\u30C9",
  TOTAL_CARDS: "\u30AB\u30FC\u30C9\u5408\u8A08",
  EDIT_LATER: "\u5F8C\u3067\u7DE8\u96C6",
  RESET_CARD_PROGRESS: "\u30AB\u30FC\u30C9\u306E\u9032\u6357\u3092\u30EA\u30BB\u30C3\u30C8",
  HARD: "Hard",
  GOOD: "Good",
  EASY: "Easy",
  SHOW_ANSWER: "\u89E3\u7B54\u3092\u8868\u793A",
  CARD_PROGRESS_RESET: "\u30AB\u30FC\u30C9\u306E\u9032\u6357\u304C\u30EA\u30BB\u30C3\u30C8\u3055\u308C\u307E\u3057\u305F\u3002",
  OPEN_NOTE_FOR_REVIEW: "\u30EC\u30D3\u30E5\u30FC\u3059\u308B\u30CE\u30FC\u30C8\u3092\u958B\u304F",
  REVIEW_CARDS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u30EC\u30D3\u30E5\u30FC",
  REVIEW_EASY_FILE_MENU: "\u30EC\u30D3\u30E5\u30FC: Easy",
  REVIEW_GOOD_FILE_MENU: "\u30EC\u30D3\u30E5\u30FC: Good",
  REVIEW_HARD_FILE_MENU: "\u30EC\u30D3\u30E5\u30FC: Hard",
  REVIEW_NOTE_EASY_CMD: "\u30CE\u30FC\u30C8\u3092Easy\u3068\u3057\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  REVIEW_NOTE_GOOD_CMD: "\u30CE\u30FC\u30C8\u3092Good\u3068\u3057\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  REVIEW_NOTE_HARD_CMD: "\u30CE\u30FC\u30C8\u3092Hard\u3068\u3057\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  REVIEW_CARDS_IN_NOTE: "\u3053\u306E\u30CE\u30FC\u30C8\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  CRAM_CARDS_IN_NOTE: "\u3053\u306E\u30CE\u30FC\u30C8\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u8A70\u3081\u8FBC\u307F\u5B66\u7FD2\u3059\u308B",
  REVIEW_ALL_CARDS: "\u3059\u3079\u3066\u306E\u30CE\u30FC\u30C8\u304B\u3089\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  VIEW_STATS: "\u7D71\u8A08\u3092\u95B2\u89A7\u3059\u308B",
  STATUS_BAR: "\u30EC\u30D3\u30E5\u30FC: ${dueNotesCount}\u30CE\u30FC\u30C8, ${dueFlashcardsCount}\u30AB\u30FC\u30C9\u304C\u671F\u65E5",
  SYNC_TIME_TAKEN: "\u540C\u671F\u306B${t}ms\u304B\u304B\u308A\u307E\u3057\u305F\u3002",
  NOTE_IN_IGNORED_FOLDER: "\u30CE\u30FC\u30C8\u304C\u7121\u8996\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u306B\u4FDD\u5B58\u3055\u308C\u3066\u3044\u307E\u3059(\u8A2D\u5B9A\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044)\u3002",
  PLEASE_TAG_NOTE: "\u30EC\u30D3\u30E5\u30FC\u3092\u884C\u3046\u306B\u306F\u30CE\u30FC\u30C8\u306B\u5BFE\u3057\u3066\u6B63\u3057\u304F\u30BF\u30B0\u4ED8\u3051\u3057\u3066\u304F\u3060\u3055\u3044(\u8A2D\u5B9A\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044)\u3002",
  RESPONSE_RECEIVED: "\u7B54\u3048\u3092\u53D7\u3051\u53D6\u308A\u307E\u3057\u305F\u3002",
  NO_DECK_EXISTS: "${deckName}\u306B\u306F\u30C7\u30C3\u30AD\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002",
  ALL_CAUGHT_UP: "\u4ECA\u65E5\u306E\u8AB2\u984C\u3092\u3059\u3079\u3066\u9054\u6210\u3057\u307E\u3057\u305F :D",
  DAYS_STR_IVL: "${interval}\u65E5\u5F8C",
  MONTHS_STR_IVL: "${interval}\u6708\u5F8C",
  YEARS_STR_IVL: "${interval}\u5E74\u5F8C",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}y",
  SETTINGS_HEADER: "Spaced Repetition Plugin - \u8A2D\u5B9A",
  CHECK_WIKI: '\u8A73\u7D30\u306B\u3064\u3044\u3066\u306F<a href="${wiki_url}">wiki</a>\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002',
  FOLDERS_TO_IGNORE: "\u7121\u8996\u3059\u308B\u30D5\u30A9\u30EB\u30C0",
  FOLDERS_TO_IGNORE_DESC: '\u30D5\u30A9\u30EB\u30C0\u30D1\u30B9\u3092\u6539\u884C\u3067\u533A\u5207\u3063\u3066\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002"Templates Meta/Scripts" \u306E\u3088\u3046\u306A\u30B9\u30DA\u30FC\u30B9\u306B\u3088\u308B\u533A\u5207\u308A\u3067\u306E\u66F8\u304D\u65B9\u306F\u7121\u52B9\u3067\u3059\u3002',
  FLASHCARDS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9",
  FLASHCARD_TAGS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BF\u30B0",
  FLASHCARD_TAGS_DESC: '\u30BF\u30B0\u3092\u30B9\u30DA\u30FC\u30B9\u307E\u305F\u306F\u6539\u884C\u3067\u533A\u5207\u3063\u3066\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u4F8B: "#flashcards #deck2 #deck3"',
  CONVERT_FOLDERS_TO_DECKS: "\u30D5\u30A9\u30EB\u30C0\u3092\u30C7\u30C3\u30AD\u3068\u30B5\u30D6\u30C7\u30C3\u30AD\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\u3053\u308C\u306F\u4E0A\u8A18\u306E\u30BF\u30B0\u3092\u4F7F\u7528\u3057\u305F\u30C7\u30C3\u30AD\u69CB\u7BC9\u306E\u4EE3\u66FF\u3068\u306A\u308B\u30AA\u30D7\u30B7\u30E7\u30F3\u3067\u3059\u3002",
  INLINE_SCHEDULING_COMMENTS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u6700\u7D42\u884C\u3068\u540C\u4E00\u306E\u884C\u306B\u30B9\u30B1\u30B8\u30E5\u30FC\u30EA\u30F3\u30B0\u30B3\u30E1\u30F3\u30C8\u3092\u4FDD\u5B58\u3057\u307E\u3059\u304B\uFF1F",
  INLINE_SCHEDULING_COMMENTS_DESC: "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6709\u52B9\u5316\u3059\u308B\u3068\u3001HTML\u30B3\u30E1\u30F3\u30C8\u306B\u3088\u3063\u3066Markdown\u306E\u30EA\u30B9\u30C8\u30D5\u30A9\u30FC\u30DE\u30C3\u30C8\u304C\u5D29\u308C\u306A\u304F\u306A\u308A\u307E\u3059\u3002",
  BURY_SIBLINGS_TILL_NEXT_DAY: "\u6B21\u306E\u30EC\u30D3\u30E5\u30FC\u307E\u3067\u30B7\u30D6\u30EA\u30F3\u30B0\u3092\u5EF6\u671F\u3057\u307E\u3059\u304B\uFF1F",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "\u30B7\u30D6\u30EA\u30F3\u30B0\u306F\u540C\u4E00\u306E\u30AB\u30FC\u30C9\u30C6\u30AD\u30B9\u30C8\u304B\u3089\u751F\u6210\u3055\u308C\u305F\u30AB\u30FC\u30C9\u3001\u3064\u307E\u308A\u7A74\u57CB\u3081\u554F\u984C\u306E\u6D3E\u751F\u30AB\u30FC\u30C9\u3067\u3059\u3002",
  SHOW_CARD_CONTEXT: "\u30AB\u30FC\u30C9\u306B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u3092\u8868\u793A\u3057\u307E\u3059\u304B\uFF1F",
  SHOW_CARD_CONTEXT_DESC: "\uFF62\u30BF\u30A4\u30C8\u30EB > \u898B\u51FA\u3057 1 > \u526F\u898B\u51FA\u3057 > ... > \u526F\u898B\u51FA\u3057\uFF63\u306E\u8868\u793A\u3092\u884C\u3046\u304B\u3069\u3046\u304B\u3092\u6C7A\u3081\u307E\u3059\u3002",
  CARD_MODAL_HEIGHT_PERCENT: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u7E26\u30B5\u30A4\u30BA\u306E\u30D1\u30FC\u30BB\u30F3\u30C6\u30FC\u30B8",
  CARD_MODAL_SIZE_PERCENT_DESC: "\u30E2\u30D0\u30A4\u30EB\u7248\u3001\u307E\u305F\u306F\u975E\u5E38\u306B\u5927\u304D\u306A\u30B5\u30A4\u30BA\u306E\u753B\u50CF\u304C\u3042\u308B\u5834\u5408\u306B\u306F100%\u306B\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002",
  RESET_DEFAULT: "\u30C7\u30D5\u30A9\u30EB\u30C8\u5024\u306B\u30EA\u30BB\u30C3\u30C8\u3059\u308B",
  CARD_MODAL_WIDTH_PERCENT: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u6A2A\u30B5\u30A4\u30BA\u306E\u30D1\u30FC\u30BB\u30F3\u30C6\u30FC\u30B8",
  FILENAME_OR_OPEN_FILE: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u30EC\u30D3\u30E5\u30FC\u3067\uFF62\u5F8C\u3067\u7DE8\u96C6\uFF63\u306E\u4EE3\u308F\u308A\u306B\u30D5\u30A1\u30A4\u30EB\u540D\u3092\u8868\u793A\u3057\u307E\u3059\u304B\uFF1F",
  RANDOMIZE_CARD_ORDER: "\u30EC\u30D3\u30E5\u30FC\u4E2D\u306E\u30AB\u30FC\u30C9\u306E\u9806\u756A\u3092\u30E9\u30F3\u30C0\u30E0\u306B\u3057\u307E\u3059\u304B\uFF1F",
  DISABLE_CLOZE_CARDS: "\u7A74\u57CB\u3081\u30AB\u30FC\u30C9\u3092\u7121\u52B9\u5316\u3057\u307E\u3059\u304B\uFF1F",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "==\u30CF\u30A4\u30E9\u30A4\u30C8==\u3092\u7A74\u57CB\u3081\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
  CONVERT_BOLD_TEXT_TO_CLOZES: "**\u30DC\u30FC\u30EB\u30C9\u4F53**\u3092\u7A74\u57CB\u3081\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
  INLINE_CARDS_SEPARATOR: "\u30A4\u30F3\u30E9\u30A4\u30F3\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
  FIX_SEPARATORS_MANUALLY_WARNING: "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u5909\u66F4\u3059\u308B\u5834\u5408\u306B\u306F\u3001\u4F5C\u6210\u6E08\u307F\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u624B\u52D5\u3067\u7DE8\u96C6\u3057\u76F4\u3059\u5FC5\u8981\u304C\u3042\u308B\u3053\u3068\u306B\u6CE8\u610F\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  INLINE_REVERSED_CARDS_SEPARATOR: "\u30A4\u30F3\u30E9\u30A4\u30F3\u306E\u8868\u88CF\u53CD\u8EE2\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
  MULTILINE_CARDS_SEPARATOR: "\u8907\u6570\u884C\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\u8907\u6570\u884C\u306E\u8868\u88CF\u53CD\u8EE2\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
  NOTES: "\u30CE\u30FC\u30C8",
  TAGS_TO_REVIEW: "\u30EC\u30D3\u30E5\u30FC\u306B\u4F7F\u7528\u3059\u308B\u30BF\u30B0",
  TAGS_TO_REVIEW_DESC: '\u30BF\u30B0\u3092\u30B9\u30DA\u30FC\u30B9\u307E\u305F\u306F\u6539\u884C\u3067\u533A\u5207\u3063\u3066\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u4F8B: "#review #tag2 #tag3"',
  OPEN_RANDOM_NOTE: "\u30E9\u30F3\u30C0\u30E0\u306B\u30CE\u30FC\u30C8\u3092\u958B\u3044\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  OPEN_RANDOM_NOTE_DESC: "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u304C\u7121\u52B9\u5316\u3055\u308C\u3066\u3044\u308B\u72B6\u614B\u3067\u306F\u3001\u30CE\u30FC\u30C8\u306F\u91CD\u8981\u5EA6(\u30DA\u30FC\u30B8\u30E9\u30F3\u30AF)\u306B\u3088\u308B\u9806\u756A\u3067\u8868\u793A\u3055\u308C\u307E\u3059\u3002",
  AUTO_NEXT_NOTE: "\u30EC\u30D3\u30E5\u30FC\u5F8C\u306B\u6B21\u306E\u30CE\u30FC\u30C8\u3092\u81EA\u52D5\u7684\u306B\u958B\u304F",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "\u30D5\u30A1\u30A4\u30EB\u30E1\u30CB\u30E5\u30FC\u3067\u306E\u30EC\u30D3\u30E5\u30FC\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u7121\u52B9\u5316(\uFF62\u30EC\u30D3\u30E5\u30FC: Easy\uFF63\u7B49\u306E\u9805\u76EE\u3092\u975E\u8868\u793A\u306B\u3059\u308B)",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\u7121\u52B9\u5316\u3057\u305F\u5F8C\u3001\u30B3\u30DE\u30F3\u30C9\u30DB\u30C3\u30C8\u30AD\u30FC\u3092\u4F7F\u3063\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B\u3053\u3068\u304C\u53EF\u80FD\u306B\u306A\u308A\u307E\u3059\u3002\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u5909\u66F4\u3057\u305F\u5834\u5408\u306B\u306FObsidian\u3092\u30EA\u30ED\u30FC\u30C9\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  MAX_N_DAYS_REVIEW_QUEUE: "\u53F3\u30D1\u30CD\u30EB\u306B\u8868\u793A\u3059\u308B\u6700\u5927\u306E\u65E5\u6570",
  MIN_ONE_DAY: "\u65E5\u6570\u306B\u306F1\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  VALID_NUMBER_WARNING: "\u6709\u52B9\u306A\u6570\u5B57\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  ALGORITHM: "\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0",
  CHECK_ALGORITHM_WIKI: '\u8A73\u7D30\u306B\u3064\u3044\u3066\u306F<a href="${algo_url}">\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u306E\u5B9F\u88C5</a>\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002',
  BASE_EASE: "\u30D9\u30FC\u30B9\u306E\u6613\u3057\u3055",
  BASE_EASE_DESC: "\u6700\u5C0F\u5024\u306F130\u3067\u3059\u304C\u3001 \u9069\u6B63\u5024\u306F\u304A\u304A\u3088\u305D250\u3067\u3059\u3002",
  BASE_EASE_MIN_WARNING: "\u30D9\u30FC\u30B9\u306E\u6613\u3057\u3055\u306B\u306F130\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  LAPSE_INTERVAL_CHANGE: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9/\u30CE\u30FC\u30C8\u3092Hard\u3068\u3057\u3066\u30EC\u30D3\u30E5\u30FC\u3057\u305F\u969B\u306E\u9593\u9694\u5909\u66F4",
  LAPSE_INTERVAL_CHANGE_DESC: '"\u65B0\u3057\u3044\u9593\u9694 = \u4EE5\u524D\u306E\u9593\u9694 * \u9593\u9694\u5909\u66F4 / 100" \u3068\u3057\u3066\u8A08\u7B97\u3055\u308C\u307E\u3059\u3002',
  EASY_BONUS: "Easy\u30DC\u30FC\u30CA\u30B9",
  EASY_BONUS_DESC: "Easy\u30DC\u30FC\u30CA\u30B9\u306B\u3088\u3063\u3066\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9/\u30CE\u30FC\u30C8\u306B\u304A\u3051\u308B\u9593\u9694\u306E\u5DEE\u5206\u3092\u8A2D\u5B9A\u3067\u304D\u307E\u3059(\u6700\u5C0F\u5024 = 100%)\u3002",
  EASY_BONUS_MIN_WARNING: "Easy\u30DC\u30FC\u30CA\u30B9\u306B\u306F100\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  MAX_INTERVAL: "\u9593\u9694\u306E\u6700\u5927\u5024",
  MAX_INTERVAL_DESC: "\u9593\u9694\u306B\u4E0A\u9650\u5024\u3092\u8A2D\u5B9A\u3059\u308B\u3053\u3068\u304C\u3067\u304D\u307E\u3059(\u30C7\u30D5\u30A9\u30EB\u30C8\u5024 = 100\u5E74)\u3002",
  MAX_INTERVAL_MIN_WARNING: "\u9593\u9694\u306E\u6700\u5927\u5024\u306B\u306F1\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  MAX_LINK_CONTRIB: "\u30EA\u30F3\u30AF\u30B3\u30F3\u30C8\u30EA\u30D3\u30E5\u30FC\u30B7\u30E7\u30F3\u306E\u6700\u5927\u5024",
  MAX_LINK_CONTRIB_DESC: "\u6700\u521D\u306E\u6613\u3057\u3055\u306B\u5BFE\u3057\u3066\u3001\u30EA\u30F3\u30AF\u3055\u308C\u305F\u30CE\u30FC\u30C8\u306E\u91CD\u307F\u4ED8\u3051\u3055\u308C\u305F\u6613\u3057\u3055\u304C\u5BC4\u4E0E\u3059\u308B\u6700\u5927\u5024\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  LOGGING: "\u30ED\u30B0\u7BA1\u7406",
  DISPLAY_DEBUG_INFO: "\u30C7\u30D9\u30ED\u30C3\u30D1\u30FC\u30B3\u30F3\u30BD\u30FC\u30EB\u306B\u3066\u30C7\u30D0\u30C3\u30B0\u60C5\u5831\u3092\u8868\u793A\u3057\u307E\u3059\u304B\uFF1F",
  NOTES_REVIEW_QUEUE: "\u30CE\u30FC\u30C8\u30EC\u30D3\u30E5\u30FC\u306E\u30AD\u30E5\u30FC",
  CLOSE: "\u9589\u3058\u308B",
  NEW: "\u65B0\u898F",
  YESTERDAY: "\u6628\u65E5",
  TODAY: "\u4ECA\u65E5",
  TOMORROW: "\u660E\u65E5",
  STATS_TITLE: "\u7D71\u8A08",
  MONTH: "Month",
  QUARTER: "Quarter",
  YEAR: "Year",
  LIFETIME: "Lifetime",
  FORECAST: "\u4E88\u6E2C",
  FORECAST_DESC: "\u5FA9\u7FD2\u671F\u65E5\u304C\u6765\u308B\u30AB\u30FC\u30C9\u306E\u679A\u6570",
  SCHEDULED: "\u30B9\u30B1\u30B8\u30E5\u30FC\u30EA\u30F3\u30B0\u6E08\u307F",
  DAYS: "\u65E5",
  NUMBER_OF_CARDS: "\u30AB\u30FC\u30C9\u6570",
  REVIEWS_PER_DAY: "\u5E73\u5747: ${avg}\u30EC\u30D3\u30E5\u30FC/\u65E5",
  INTERVALS: "\u9593\u9694",
  INTERVALS_DESC: "\u6B21\u306E\u30EC\u30D3\u30E5\u30FC\u4E88\u5B9A\u65E5",
  COUNT: "\u30AB\u30A6\u30F3\u30C8",
  INTERVALS_SUMMARY: "\u9593\u9694\u306E\u5E73\u5747\u5024: ${avg}, \u6700\u9577\u306E\u9593\u9694: ${longest}",
  EASES: "\u6613\u3057\u3055",
  EASES_SUMMARY: "\u6613\u3057\u3055\u306E\u5E73\u5747\u5024: ${avgEase}",
  CARD_TYPES: "\u30AB\u30FC\u30C9\u30BF\u30A4\u30D7",
  CARD_TYPES_DESC: "\u5EF6\u671F\u306E\u30AB\u30FC\u30C9\u304C\u3042\u308B\u5834\u5408\u306B\u306F\u3053\u308C\u306B\u542B\u307E\u308C\u307E\u3059",
  CARD_TYPE_NEW: "\u65B0\u898F",
  CARD_TYPE_YOUNG: "\u5FA9\u7FD2(\u521D\u671F)",
  CARD_TYPE_MATURE: "\u5FA9\u7FD2(\u5F8C\u671F)",
  CARD_TYPES_SUMMARY: "\u30AB\u30FC\u30C9\u306E\u5408\u8A08: ${totalCardsCount}\u679A"
};

// src/lang/locale/ko.ts
var ko_default = {};

// src/lang/locale/nl.ts
var nl_default = {};

// src/lang/locale/no.ts
var no_default = {};

// src/lang/locale/pl.ts
var pl_default = {};

// src/lang/locale/pt.ts
var pt_default = {};

// src/lang/locale/pt-br.ts
var pt_br_default = {};

// src/lang/locale/ro.ts
var ro_default = {};

// src/lang/locale/ru.ts
var ru_default = {
  DECKS: "\u0423\u0440\u043E\u0432\u043D\u0438",
  DUE_CARDS: "\u041F\u0440\u0435\u0434\u0441\u0442\u043E\u044F\u0449\u0438\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  NEW_CARDS: "\u041D\u043E\u0432\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  TOTAL_CARDS: "\u0412\u0441\u0435\u0433\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  EDIT_LATER: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u043E\u0441\u043B\u0435",
  RESET_CARD_PROGRESS: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u043F\u0440\u043E\u0433\u0440\u0435\u0441\u0441 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  HARD: "\u0421\u043B\u043E\u0436\u043D\u043E",
  GOOD: "\u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u043E",
  EASY: "\u041B\u0435\u0433\u043A\u043E",
  SHOW_ANSWER: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u043E\u0442\u0432\u0435\u0442",
  CARD_PROGRESS_RESET: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u043F\u0440\u043E\u0433\u0440\u0435\u0441\u0441 \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  OPEN_NOTE_FOR_REVIEW: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u0434\u043B\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
  REVIEW_CARDS: "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  REVIEW_EASY_FILE_MENU: "\u041F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0435: \u041B\u0435\u0433\u043A\u043E",
  REVIEW_GOOD_FILE_MENU: "\u041F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0435: \u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u043E",
  REVIEW_HARD_FILE_MENU: "\u041F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0435: \u0421\u043B\u043E\u0436\u043D\u043E",
  REVIEW_NOTE_EASY_CMD: "\u041F\u043E\u0432\u0442\u043E\u0440\u044F\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u043A\u0430\u043A \u041B\u0451\u0433\u043A\u0443\u044E",
  REVIEW_NOTE_GOOD_CMD: "\u041F\u043E\u0432\u0442\u043E\u0440\u044F\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u043A\u0430\u043A \u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u0443\u044E",
  REVIEW_NOTE_HARD_CMD: "\u041F\u043E\u0432\u0442\u043E\u0440\u044F\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u043A\u0430\u043A \u0421\u043B\u043E\u0436\u043D\u0443\u044E",
  REVIEW_CARDS_IN_NOTE: "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u044D\u0442\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0435",
  CRAM_CARDS_IN_NOTE: "\u0417\u0443\u0431\u0440\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u044D\u0442\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0435",
  REVIEW_ALL_CARDS: "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C \u0432\u0441\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432\u043E \u0432\u0441\u0435\u0445 \u0437\u0430\u043C\u0435\u0442\u043A\u0430\u0445",
  VIEW_STATS: "\u041F\u043E\u0441\u043C\u043E\u0442\u0440\u0435\u0442\u044C \u0441\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043A\u0443",
  STATUS_BAR: "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C: ${dueNotesCount} \u0437\u0430\u043C\u0435\u0442\u043E\u043A(-\u043A\u0438), ${dueFlashcardsCount} \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A(-\u043A\u0438) \u043F\u0440\u0435\u0434\u0441\u0442\u043E\u0438\u0442",
  SYNC_TIME_TAKEN: "\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u0437\u0430\u043D\u044F\u043B\u0430 ${t}\u043C\u0441",
  NOTE_IN_IGNORED_FOLDER: "\u0417\u0430\u043C\u0435\u0442\u043A\u0430 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0430 \u0432 \u0438\u0433\u043D\u043E\u0440\u0438\u0440\u0443\u0435\u043C\u0443\u044E \u043F\u0430\u043F\u043A\u0443 (\u0441\u043C \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438).",
  PLEASE_TAG_NOTE: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430 \u043F\u043E\u043C\u0435\u0442\u044C\u0442\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u043A\u0430\u043A \u043D\u0430\u0434\u043E \u0434\u043B\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F (\u0441\u043C \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438).",
  RESPONSE_RECEIVED: "\u041E\u0442\u0432\u0435\u0442 \u043F\u043E\u043B\u0443\u0447\u0435\u043D.",
  NO_DECK_EXISTS: "\u041D\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0443\u0440\u043E\u0432\u043D\u044F ${deckName}",
  ALL_CAUGHT_UP: "\u0415\u0441\u0442\u044C! \u0422\u044B \u0441\u043F\u0440\u0430\u0432\u0438\u043B\u0441\u044F! :D.",
  DAYS_STR_IVL: "${interval} \u0434\u043D\u0435\u0439",
  MONTHS_STR_IVL: "${interval} \u043C\u0435\u0441\u044F\u0446\u043E\u0432",
  YEARS_STR_IVL: "${interval} \u0433\u043E\u0434\u0430(\u043B\u0435\u0442)",
  DAYS_STR_IVL_MOBILE: "${interval}\u0434",
  MONTHS_STR_IVL_MOBILE: "${interval}\u043C",
  YEARS_STR_IVL_MOBILE: "${interval}\u0433",
  SETTINGS_HEADER: "Spaced Repetition \u041F\u043B\u0430\u0433\u0438\u043D - \u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438",
  CHECK_WIKI: '\u0414\u043B\u044F \u0434\u043E\u043F \u0438\u043D\u0444\u044B, \u0441\u043C\u043E\u0442\u0440\u0438 <a href="${wiki_url}">wiki</a>. \u0421\u043A\u043E\u0440\u043E \u0431\u0443\u0434\u0435\u0442 \u043F\u0435\u0440\u0435\u0432\u043E\u0434 :3',
  FOLDERS_TO_IGNORE: "\u0418\u0433\u043D\u043E\u0440\u0438\u0440\u0443\u0435\u043C\u044B\u0435 \u043F\u0430\u043F\u043A\u0438",
  FOLDERS_TO_IGNORE_DESC: "\u0412\u0435\u0434\u0438\u0442\u0435 \u043F\u0443\u0442\u0438 \u043F\u0430\u043F\u043E\u043A \u0440\u0430\u0437\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 enter'\u043E\u043C \u043F\u0440\u0438\u043C\u0435\u0440: Templates Meta/Scripts",
  FLASHCARDS: "\u041A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  FLASHCARD_TAGS: "\u0422\u044D\u0433\u0438 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  FLASHCARD_TAGS_DESC: "\u0412\u0435\u0434\u0438\u0442\u0435 \u0442\u044D\u0433\u0438 \u0440\u0430\u0437\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 enter'\u043E\u043C \u0438\u043B\u0438 \u043F\u0440\u043E\u0431\u0435\u043B\u043E\u043C \u043F\u0440\u0438\u043C\u0435\u0440: #flashcards #deck2 #deck3.",
  CONVERT_FOLDERS_TO_DECKS: "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u0430\u043F\u043A\u0438 \u0432 \u0443\u0440\u043E\u0432\u043D\u0438 \u0438 \u043F\u043E\u0434\u0443\u0440\u043E\u0432\u043D\u0438?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\u042D\u0442\u043E \u0430\u043B\u044C\u0442\u0435\u0440\u043D\u0430\u0442\u0438\u0432\u0430 \u0442\u044D\u0433\u0430\u043C \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A, \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430 \u0441\u0432\u0435\u0440\u0445\u0443.",
  INLINE_SCHEDULING_COMMENTS: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0439 \u043F\u043B\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F \u043D\u0430 \u0441\u0442\u0440\u043E\u043A\u0435 \u043F\u043E\u0441\u043B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A?",
  INLINE_SCHEDULING_COMMENTS_DESC: "\u0412\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435 \u044D\u0442\u043E\u0433\u043E \u0441\u0434\u0435\u043B\u0430\u0435\u0442 \u0442\u0430\u043A, \u0447\u0442\u043E HTML \u043A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0438 \u043D\u0435 \u0431\u0443\u0434\u0443\u0442 \u043B\u043E\u043C\u0430\u0442\u044C \u0444\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0441\u043F\u0438\u0441\u043A\u0430.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "\u041F\u0440\u044F\u0442\u0430\u0442\u044C \u0440\u043E\u0434\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0434\u043E \u0441\u043B\u0435\u0434. \u0434\u043D\u044F?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "\u0420\u043E\u0434\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 - \u0442\u0435, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D\u044B \u0438\u0437 \u043E\u0434\u043D\u043E\u0433\u043E \u0442\u0435\u043A\u0441\u0442\u0430, \u043F\u0440\u0438\u043C\u0435\u0440: \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0441 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u043C\u0438([...])",
  SHOW_CARD_CONTEXT: "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442(\u0443\u0440\u043E\u0432\u0435\u043D\u044C) \u0432 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0430\u0445(\u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F)?",
  SHOW_CARD_CONTEXT_DESC: "\u043F\u0440\u0438\u043C\u0435\u0440: Title > Heading 1 > Subheading > ... > Subheading",
  CARD_MODAL_HEIGHT_PERCENT: "\u0412\u044B\u0441\u043E\u0442\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432\u043F\u0440\u043E\u0446\u0435\u043D\u0442\u0430\u0445",
  CARD_MODAL_SIZE_PERCENT_DESC: "\u0415\u0441\u043B\u0438 \u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442\u0435\u0441\u044C \u043C\u043E\u0431\u0438\u043B\u044C\u043D\u044B\u043C \u0442\u0435\u043B\u0435\u0444\u043E\u043D\u043E\u043C, \u0432\u044B\u0441\u0442\u0430\u0432\u044C\u0442\u0435 100% \u0438\u043B\u0438 \u0443 \u0432\u0430\u0441 \u0431\u0443\u0434\u0443\u0442 \u043E\u0433\u0440\u043E\u043C\u043D\u044B\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F",
  RESET_DEFAULT: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
  CARD_MODAL_WIDTH_PERCENT: "\u0428\u0438\u0440\u0438\u043D\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u043F\u0440\u043E\u0446\u0435\u043D\u0442\u0430\u0445",
  FILENAME_OR_OPEN_FILE: "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u0438\u043C\u044F \u0444\u0430\u0439\u043B\u0430 \u0432\u043C\u0435\u0441\u0442\u043E '\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u043E\u0441\u043B\u0435' \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F?",
  RANDOMIZE_CARD_ORDER: "\u0421\u043B\u0443\u0447\u0430\u0439\u043D\u044B\u0439 \u043F\u043E\u0440\u044F\u0434\u043E\u043A \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F?",
  DISABLE_CLOZE_CARDS: "\u0412\u044B\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u044B \u0441 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u043C\u0438(\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C ==\u0432\u044B\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0439 \u0442\u0435\u043A\u0441\u0442== \u0432 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0438(\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
  CONVERT_BOLD_TEXT_TO_CLOZES: "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C **\u0436\u0438\u0440\u043D\u044B\u0439 \u0442\u0435\u043A\u0441\u0442** \u0432 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0438(\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
  INLINE_CARDS_SEPARATOR: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u0432\u043D\u0443\u0442\u0440\u0438\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  FIX_SEPARATORS_MANUALLY_WARNING: "\u0412\u043D\u0438\u043C\u0430\u043D\u0438\u0435! \u043F\u043E\u0441\u043B\u0435 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u044D\u0442\u043E\u0433\u043E \u0432\u0430\u043C \u043F\u0440\u0438\u0434\u0451\u0442\u0441\u044F \u0432\u0440\u0443\u0447\u043D\u0443\u044E \u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  INLINE_REVERSED_CARDS_SEPARATOR: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u043E\u0431\u0440\u0430\u0442\u043D\u044B\u0445 \u0432\u043D\u0443\u0442\u0440\u0438\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  MULTILINE_CARDS_SEPARATOR: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u043C\u043D\u043E\u0433\u043E\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u043E\u0431\u0440\u0430\u0442\u043D\u044B\u0445 \u043C\u043D\u043E\u0433\u043E\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  NOTES: "\u0417\u0430\u043C\u0435\u0442\u043A\u0438",
  TAGS_TO_REVIEW: "\u0422\u044D\u0433\u0438 \u0434\u043B\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
  TAGS_TO_REVIEW_DESC: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0442\u044D\u0433\u0438, \u0440\u0430\u0437\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 \u043F\u0440\u043E\u0431\u0435\u043B\u0430\u043C\u0438 \u0438\u043B\u0438 enter`\u0430\u043C\u0438, \u043F\u0440\u0438\u043C\u0435\u0440: #review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0441\u043B\u0443\u0447\u0430\u0439\u043D\u0443\u044E \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u0434\u043B\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
  OPEN_RANDOM_NOTE_DESC: "\u0415\u0441\u043B\u0438 \u0432\u044B\u043A\u043B\u044E\u0447\u0438\u0442\u044C, \u0442\u043E \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0431\u0443\u0434\u0443\u0442 \u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u044C \u043F\u043E \u0432\u0430\u0436\u043D\u043E\u0441\u0442\u0438 (PageRank).",
  AUTO_NEXT_NOTE: "\u041E\u0442\u043A\u0440\u044B\u0432\u0430\u0442\u044C \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u043F\u043E\u0441\u043B\u0435 \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "\u0412\u044B\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0432\u044B\u0431\u043E\u0440 \u0441\u043B\u043E\u0436\u043D\u043E\u0441\u0442\u0438 \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F \u0432 \u043C\u0435\u043D\u044E \u0444\u0430\u0439\u043B\u0430, \u043F\u0440\u0438\u043C\u0435\u0440: \u041F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0435: \u041B\u0435\u0433\u043A\u043E \u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u043E \u0421\u043B\u043E\u0436\u043D\u043E",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\u041F\u043E\u0441\u043B\u0435 \u0432\u044B\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F \u0432\u044B \u0441\u043C\u043E\u0436\u0435\u0442\u0435 \u043F\u043E\u0432\u0442\u043E\u0440\u044F\u0442\u044C \u043F\u0440\u0438 \u043F\u043E\u043C\u043E\u0449\u0438 \u0445\u043E\u0442\u043A\u0435\u0435\u0432. \u041F\u0435\u0440\u0435\u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u0435 Obsidian \u043F\u043E\u0441\u043B\u0435 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u044D\u0442\u043E\u0433\u043E.",
  MAX_N_DAYS_REVIEW_QUEUE: "\u041D\u0430\u0438\u0431\u043E\u043B\u044C\u0448\u0435\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0434\u043D\u0435\u0439 \u0434\u043B\u044F \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u043D\u0430 \u043F\u0430\u043D\u0435\u043B\u0438 \u0441\u043F\u0440\u0430\u0432\u0430",
  MIN_ONE_DAY: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0434\u043D\u0435\u0439 \u043D\u0435 \u043C\u0435\u043D\u044C\u0448\u0435 1.",
  VALID_NUMBER_WARNING: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430 \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u043F\u043E\u0434\u0445\u043E\u0434\u044F\u0449\u0435\u0435 \u0447\u0438\u0441\u043B\u043E.",
  ALGORITHM: "\u0410\u043B\u0433\u043E\u0440\u0438\u0442\u043C",
  CHECK_ALGORITHM_WIKI: '\u0417\u0430 \u0434\u043E\u043F\u043E\u043B\u043D\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0439 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0435\u0439 \u043E\u0431\u0440\u0430\u0449\u0430\u0439\u0442\u0435\u0441\u044C \u043A <a href="${algo_url}">\u0440\u0435\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F \u0430\u043B\u0433\u043E\u0440\u0438\u0442\u043C\u0430</a>(\u0441\u043A\u043E\u0440\u043E \u0431\u0443\u0434\u0435\u0442 \u043F\u0435\u0440\u0435\u0432\u043E\u0434).',
  BASE_EASE: "\u0411\u0430\u0437\u043E\u0432\u0430\u044F \u041F\u0440\u043E\u0441\u0442\u043E\u0442\u0430",
  BASE_EASE_DESC: "\u043C\u0438\u043D\u0438\u043C\u0443\u043C = 130, \u043F\u0440\u0435\u0434\u043F\u043E\u0447\u0442\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u043E\u043A\u043E\u043B\u043E 250.",
  BASE_EASE_MIN_WARNING: "\u041F\u0440\u043E\u0441\u0442\u043E\u0442\u0430 \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0438\u043D\u0438\u043C\u0443\u043C 130.",
  LAPSE_INTERVAL_CHANGE: "\u0418\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0435 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0430 \u043A\u043E\u0433\u0434\u0430 \u0432\u044B \u043E\u0442\u0432\u0435\u0447\u0430\u0435\u0442\u0435 \u0421\u043B\u043E\u0436\u043D\u043E \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438/\u0437\u0430\u043C\u0435\u0442\u043A\u0438",
  LAPSE_INTERVAL_CHANGE_DESC: "\u043D\u043E\u0432\u044B\u0439\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A = \u0441\u0442\u0430\u0440\u044B\u0439\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A * \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0435\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0430 / 100.",
  EASY_BONUS: "\u041B\u0435\u0433\u043A\u043E: \u0431\u043E\u043D\u0443\u0441",
  EASY_BONUS_DESC: "\u0411\u043E\u043D\u0443\u0441 \u0437\u0430 \u041B\u0435\u0433\u043A\u043E \u043F\u043E\u0437\u0432\u043E\u043B\u044F\u0435\u0442 \u0432\u0430\u043C \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0440\u0430\u0437\u043D\u0438\u0446\u0443 \u0432 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0430\u0445 \u043C\u0435\u0436\u0434\u0443 \u043E\u0442\u0432\u0435\u0442\u0430\u043C\u0438 \u0425\u043E\u0440\u043E\u0448\u043E \u0438 \u041B\u0435\u0433\u043A\u043E \u043D\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0435/\u0437\u0430\u043C\u0435\u0442\u043A\u0435 (\u043C\u0438\u043D. = 100%).",
  EASY_BONUS_MIN_WARNING: "\u0411\u043E\u043D\u0443\u0441 \u0437\u0430 \u041B\u0435\u0433\u043A\u043E \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u043D\u0435 \u043C\u0435\u043D\u044C\u0448\u0435 100.",
  MAX_INTERVAL: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A(\u043E\u0442\u043A\u043B\u0430\u0434\u044B\u0432\u0430\u043D\u0438\u044F \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438)",
  MAX_INTERVAL_DESC: "\u041F\u043E\u0437\u0432\u043E\u043B\u044F\u0435\u0442 \u0432\u0430\u043C \u0443\u0441\u0442\u0430\u043D\u0430\u0432\u043B\u0438\u0432\u0430\u0442\u044C \u0432\u0435\u0440\u0445\u043D\u044E\u044E \u0433\u0440\u0430\u043D\u0438\u0446\u0443 \u043D\u0430 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A (\u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E = 100 years).",
  MAX_INTERVAL_MIN_WARNING: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u043D\u0435 \u043C\u0435\u043D\u044C\u0448\u0435 1.",
  MAX_LINK_CONTRIB: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0432\u043A\u043B\u0430\u0434 \u0441\u0432\u044F\u0437\u0438(\u0441\u0441\u044B\u043B\u043A\u0438)",
  MAX_LINK_CONTRIB_DESC: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0432\u043A\u043B\u0430\u0434 \u0432\u0437\u0432\u0435\u0448\u0435\u043D\u043D\u043E\u0439 \u041F\u0440\u043E\u0441\u0442\u043E\u0442\u044B \u0441\u0432\u044F\u0437\u0430\u043D\u043D\u044B\u0445 \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u0432 \u043D\u0430\u0447\u0430\u043B\u044C\u043D\u0443\u044E \u041F\u0440\u043E\u0441\u0442\u043E\u0442\u0443.",
  LOGGING: "\u0412\u0435\u0434\u0435\u043D\u0438\u0435 \u043B\u043E\u0433\u0430",
  DISPLAY_DEBUG_INFO: "\u041E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0442\u044C \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044E \u043E\u0442\u043B\u0430\u0434\u043A\u0438 \u043D\u0430 \u043A\u043E\u043D\u0441\u043E\u043B\u044C \u0440\u0430\u0437\u0440\u0430\u0431\u043E\u0442\u0447\u0438\u043A\u0430(developer console)?",
  NOTES_REVIEW_QUEUE: "\u041E\u0447\u0435\u0440\u0435\u0434\u044C \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u043D\u0430 \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0435",
  CLOSE: "\u0417\u0430\u043A\u0440\u044B\u0442\u044C",
  NEW: "\u041D\u043E\u0432\u044B\u0435",
  YESTERDAY: "\u0412\u0447\u0435\u0440\u0430\u0448\u043D\u0438\u0435",
  TODAY: "\u0417\u0430\u0432\u0442\u0440\u0430\u0448\u043D\u0438\u0435",
  TOMORROW: "\u041F\u043E\u0441\u043B\u0435\u0437\u0430\u0432\u0442\u0440\u0430\u0448\u043D\u0438\u0435",
  STATS_TITLE: "\u0421\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043A\u0430",
  MONTH: "\u041C\u0435\u0441\u044F\u0446",
  QUARTER: "\u0427\u0435\u0442\u0432\u0435\u0440\u0442\u044C",
  YEAR: "\u0413\u043E\u0434",
  LIFETIME: "\u0412\u0441\u0451 \u0432\u0440\u0435\u043C\u044F",
  FORECAST: "\u041F\u0440\u043E\u0433\u043D\u043E\u0437",
  FORECAST_DESC: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A \u043F\u0440\u0435\u0434\u0441\u0442\u043E\u044F\u0449\u0438\u0445 \u0432 \u0431\u0443\u0434\u0443\u0449\u0435\u043C",
  SCHEDULED: "\u0417\u0430\u043F\u043B\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u043E",
  DAYS: "\u0414\u043D\u0435\u0439",
  NUMBER_OF_CARDS: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  REVIEWS_PER_DAY: "\u0421\u0440\u0435\u0434\u043D\u0435\u0435 \u043A\u043E\u043B\u0438\u0447\u0441\u0442\u0432\u043E: ${avg} \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0439/\u0434\u0435\u043D\u044C",
  INTERVALS: "\u0418\u043D\u0442\u0435\u0440\u0432\u0430\u043B\u044B",
  INTERVALS_DESC: "\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0438 \u0432\u0440\u0435\u043C\u0435\u043D\u0438 \u0434\u043E \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E \u043F\u043E\u043A\u0430\u0437\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
  COUNT: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E",
  INTERVALS_SUMMARY: "\u0421\u0440\u0435\u0434\u043D\u0438\u0439 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A: ${avg}, \u0421\u0430\u043C\u044B\u0439 \u0434\u043B\u0438\u043D\u043D\u044B\u0439 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A: ${longest}",
  EASES: "\u041F\u0440\u043E\u0441\u0442\u043E\u0442\u0430(\u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440 \u0432 \u0430\u043B\u0433\u043E\u0440\u0438\u0442\u043C\u0435, \u043A\u043E\u0442\u043E\u0440\u044B\u0439 \u0432\u043B\u0438\u044F\u0435\u0442 \u043D\u0430 \u043F\u0440\u0438\u043E\u0440\u0438\u0442\u0435\u0442 \u0438 \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u043A\u0430\u0437\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A) \n (\u043E\u0442 \u0430\u043D\u0433\u043B. ease, \u0441\u043C \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0430\u043B\u0433\u043E\u0440\u0438\u0442\u043C\u0430)",
  EASES_SUMMARY: "\u0421\u0440\u0435\u0434\u043D\u0435\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u041F\u0440\u043E\u0441\u0442\u043E\u0442\u044B: ${avgEase}",
  CARD_TYPES: "\u0422\u0438\u043F\u044B \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  CARD_TYPES_DESC: "\u042D\u0442\u043E \u0432\u043A\u043B\u044E\u0447\u0430\u044F \u0441\u043F\u0440\u044F\u0442\u0430\u043D\u043D\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438, \u0435\u0441\u043B\u0438 \u0447\u0442\u043E:",
  CARD_TYPE_NEW: "\u041D\u043E\u0432\u044B\u0445",
  CARD_TYPE_YOUNG: "\u041C\u043E\u043B\u043E\u0434\u044B\u0445",
  CARD_TYPE_MATURE: "\u0412\u0437\u0440\u043E\u0441\u043B\u044B\u0445",
  CARD_TYPES_SUMMARY: "\u0412\u0441\u0435\u0433\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A: ${totalCardsCount}"
};

// src/lang/locale/tr.ts
var tr_default = {};

// src/lang/locale/zh-cn.ts
var zh_cn_default = {
  DECKS: "\u5361\u7EC4",
  DUE_CARDS: "\u5230\u671F\u5361\u7247",
  NEW_CARDS: "\u65B0\u5361\u7247",
  TOTAL_CARDS: "\u5168\u90E8\u5361\u7247",
  EDIT_LATER: "\u7A0D\u540E\u7F16\u8F91",
  RESET_CARD_PROGRESS: "\u91CD\u7F6E\u5361\u7247",
  HARD: "\u8F83\u96BE",
  GOOD: "\u8BB0\u5F97",
  EASY: "\u7B80\u5355",
  SHOW_ANSWER: "\u663E\u793A\u7B54\u6848",
  CARD_PROGRESS_RESET: "\u5361\u7247\u5DF2\u88AB\u91CD\u7F6E\u3002",
  OPEN_NOTE_FOR_REVIEW: "\u6253\u5F00\u4E00\u4E2A\u7B14\u8BB0\u5F00\u59CB\u590D\u4E60",
  REVIEW_CARDS: "\u590D\u4E60\u5361\u7247",
  REVIEW_EASY_FILE_MENU: "\u590D\u4E60\uFF1A \u7B80\u5355",
  REVIEW_GOOD_FILE_MENU: "\u590D\u4E60\uFF1A \u8BB0\u5F97",
  REVIEW_HARD_FILE_MENU: "\u590D\u4E60\uFF1A \u8F83\u96BE",
  REVIEW_NOTE_EASY_CMD: "\u6807\u8BB0\u4E3A\u201C\u7B80\u5355\u201D",
  REVIEW_NOTE_GOOD_CMD: "\u6807\u8BB0\u4E3A\u201C\u8BB0\u5F97\u201D",
  REVIEW_NOTE_HARD_CMD: "\u6807\u8BB0\u4E3A\u201C\u8F83\u96BE\u201D",
  REVIEW_CARDS_IN_NOTE: "\u590D\u4E60\u6B64\u7B14\u8BB0\u4E2D\u7684\u5361\u7247",
  CRAM_CARDS_IN_NOTE: "\u96C6\u4E2D\u590D\u4E60\u6B64\u7B14\u8BB0\u4E2D\u7684\u5361\u7247",
  REVIEW_ALL_CARDS: "\u590D\u4E60\u6240\u6709\u7B14\u8BB0\u4E2D\u7684\u5361\u7247",
  VIEW_STATS: "\u67E5\u770B\u6570\u636E",
  STATUS_BAR: "\u590D\u4E60: ${dueNotesCount} \u7B14\u8BB0, ${dueFlashcardsCount} \u5361\u7247\u5DF2\u5230\u671F",
  SYNC_TIME_TAKEN: "\u540C\u6B65\u65F6\u95F4 ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "\u7B14\u8BB0\u4FDD\u5B58\u5728\u5DF2\u88AB\u5FFD\u7565\u7684\u8DEF\u5F84\u4E2D\uFF08\u68C0\u67E5\u8BBE\u7F6E\u9009\u9879\uFF09\u3002",
  PLEASE_TAG_NOTE: "\u8BF7\u5C06\u9700\u8981\u590D\u4E60\u7684\u7B14\u8BB0\u4E2D\u52A0\u5165\u6B63\u786E\u7684\u6807\u7B7E\uFF08\u68C0\u67E5\u8BBE\u7F6E\u9009\u9879\uFF09\u3002",
  RESPONSE_RECEIVED: "\u56DE\u5E94\u5DF2\u6536\u5230",
  NO_DECK_EXISTS: "\u6CA1\u6709 ${deckName} \u5361\u7EC4",
  ALL_CAUGHT_UP: "\u90FD\u590D\u4E60\u5B8C\u5566\uFF0C\u4F60\u771F\u68D2\uFF01",
  DAYS_STR_IVL: "${interval} \u5929",
  MONTHS_STR_IVL: "${interval} \u6708",
  YEARS_STR_IVL: "${interval} \u5E74",
  DAYS_STR_IVL_MOBILE: "${interval}\u5929",
  MONTHS_STR_IVL_MOBILE: "${interval}\u6708",
  YEARS_STR_IVL_MOBILE: "${interval}\u5E74",
  SETTINGS_HEADER: "\u95F4\u9694\u91CD\u590D\u63D2\u4EF6 - \u8BBE\u7F6E",
  CHECK_WIKI: '\u4E86\u89E3\u66F4\u591A, \u8BF7\u70B9\u51FB <a href="${wiki_url}">wiki</a>.',
  FOLDERS_TO_IGNORE: "\u5FFD\u7565\u6B64\u6587\u4EF6\u5939",
  FOLDERS_TO_IGNORE_DESC: "\u8F93\u5165\u6587\u4EF6\u5939\u8DEF\u5F84\uFF0C\u7528\u65B0\u5EFA\u884C\u5206\u9694\uFF0C\u4F8B\u5982\uFF1A Templates Meta/Scripts",
  FLASHCARDS: "\u5361\u7247",
  FLASHCARD_TAGS: "\u5361\u7247\u6807\u7B7E",
  FLASHCARD_TAGS_DESC: "\u8F93\u5165\u6807\u7B7E\uFF0C\u7528\u7A7A\u683C\u6216\u65B0\u5EFA\u884C\u5206\u9694\uFF0C\u4F8B\u5982\uFF1A #flashcards #deck2 #deck3.",
  CONVERT_FOLDERS_TO_DECKS: "\u662F\u5426\u5C06\u6587\u4EF6\u5939\u5185\u5BB9\u8F6C\u6362\u4E3A\u5361\u7247\u7EC4\u548C\u5B50\u5361\u7247\u7EC4\uFF1F",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\u6B64\u9009\u9879\u4E3A\u5361\u7247\u6807\u7B7E\u9009\u9879\u7684\u66FF\u4EE3\u9009\u9879\u3002",
  INLINE_SCHEDULING_COMMENTS: "\u662F\u5426\u5C06\u8BA1\u5212\u91CD\u590D\u65F6\u95F4\u4FDD\u5B58\u5728\u5361\u7247\u6700\u540E\u4E00\u884C\u7684\u540C\u4E00\u884C\uFF1F",
  INLINE_SCHEDULING_COMMENTS_DESC: "HTML\u6CE8\u91CA\u4E0D\u518D\u7834\u574F\u5217\u8868\u683C\u5F0F",
  BURY_SIBLINGS_TILL_NEXT_DAY: "\u5C06\u5173\u8054\u5361\u7247\u9690\u85CF\u81F3\u4E0B\u4E00\u5929\uFF1F",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "\u5173\u8054\u5361\u7247\u662F\u6765\u81EA\u540C\u4E00\u5361\u7247\u7684\u4E0D\u540C\u5F62\u5F0F\uFF0C \u4F8B\u5982\uFF1A \u5B8C\u5F62\u586B\u7A7A\u5361\u7247",
  SHOW_CARD_CONTEXT: "\u5728\u5361\u7247\u4E2D\u663E\u793A\u4E0A\u4E0B\u6587\uFF1F",
  SHOW_CARD_CONTEXT_DESC: "\u4F8B\u5982\uFF1A \u6807\u9898 > \u526F\u6807\u9898 > \u5C0F\u6807\u9898 > ... > \u5C0F\u6807\u9898",
  CARD_MODAL_HEIGHT_PERCENT: "\u5361\u7247\u9AD8\u5EA6\u767E\u5206\u6BD4",
  CARD_MODAL_SIZE_PERCENT_DESC: "\u8BF7\u5728\u79FB\u52A8\u7AEF\u4F7F\u7528\u5E76\u9700\u8981\u6D4F\u89C8\u8F83\u5927\u56FE\u7247\u65F6\u8BBE\u4E3A100%",
  RESET_DEFAULT: "\u91CD\u7F6E\u4E3A\u9ED8\u8BA4",
  CARD_MODAL_WIDTH_PERCENT: "\u5361\u7247\u5BBD\u5EA6\u767E\u5206\u6BD4",
  FILENAME_OR_OPEN_FILE: "\u5728\u590D\u4E60\u5361\u7247\u65F6\u663E\u793A\u6587\u4EF6\u540D\u79F0\u800C\u4E0D\u662F\u201C\u7A0D\u540E\u7F16\u8F91\u201D\uFF1F",
  RANDOMIZE_CARD_ORDER: "\u590D\u4E60\u65F6\u968F\u673A\u663E\u793A\u5361\u7247\uFF1F",
  DISABLE_CLOZE_CARDS: "\u4E0D\u8FDB\u884C\u5B8C\u5F62\u586B\u7A7A\uFF1F",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "\u5C06 ==\u9AD8\u4EAE== \u8F6C\u6362\u4E3A\u5B8C\u5F62\u586B\u7A7A\uFF1F",
  CONVERT_BOLD_TEXT_TO_CLOZES: "\u5C06 **\u7C97\u4F53** \u8F6C\u6362\u4E3A\u5B8C\u5F62\u586B\u7A7A\uFF1F",
  INLINE_CARDS_SEPARATOR: "\u5355\u884C\u5361\u7247\u7684\u5206\u9694\u7B26",
  FIX_SEPARATORS_MANUALLY_WARNING: "\u6CE8\u610F\uFF1A \u66F4\u6539\u6B64\u9009\u9879\u540E\u4F60\u5C06\u9700\u8981\u81EA\u884C\u66F4\u6539\u5DF2\u5B58\u5728\u5361\u7247\u7684\u5206\u9694\u7B26\u3002",
  INLINE_REVERSED_CARDS_SEPARATOR: "\u5355\u884C\u7FFB\u8F6C\u5361\u7247\u7684\u5206\u9694\u7B26",
  MULTILINE_CARDS_SEPARATOR: "\u591A\u884C\u5361\u7247\u7684\u5206\u9694\u7B26",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\u591A\u884C\u7FFB\u8F6C\u5361\u7247\u7684\u5206\u9694\u7B26",
  NOTES: "\u7B14\u8BB0",
  TAGS_TO_REVIEW: "\u590D\u4E60\u6807\u7B7E",
  TAGS_TO_REVIEW_DESC: "\u8F93\u5165\u6807\u7B7E\uFF0C\u7528\u7A7A\u683C\u6216\u65B0\u5EFA\u884C\u5206\u9694\uFF0C\u4F8B\u5982\uFF1A #review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "\u590D\u4E60\u968F\u673A\u7B14\u8BB0",
  OPEN_RANDOM_NOTE_DESC: "\u5173\u95ED\u6B64\u9009\u9879\uFF0C\u7B14\u8BB0\u5C06\u4EE5\u91CD\u8981\u5EA6(PageRank)\u6392\u5E8F\u3002",
  AUTO_NEXT_NOTE: "\u590D\u4E60\u540E\u81EA\u52A8\u6253\u5F00\u4E0B\u4E00\u4E2A\u7B14\u8BB0",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "\u5173\u95ED\u6587\u4EF6\u9009\u5355\u4E2D\u7684\u590D\u4E60\u9009\u9879 \u4F8B\u5982\uFF1A \u590D\u4E60\uFF1A \u7B80\u5355 \u8BB0\u5F97 \u8F83\u96BE",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\u5173\u95ED\u6B64\u9009\u9879\u540E\u4F60\u53EF\u4EE5\u4F7F\u7528\u5FEB\u6377\u952E\u5F00\u59CB\u590D\u4E60\u3002\u91CD\u65B0\u542F\u52A8Obsidian\u4F7F\u672C\u9009\u9879\u751F\u6548\u3002",
  MAX_N_DAYS_REVIEW_QUEUE: "\u53F3\u8FB9\u680F\u4E2D\u663E\u793A\u7684\u6700\u5927\u5929\u6570",
  MIN_ONE_DAY: "\u5929\u6570\u6700\u5C0F\u503C\u4E3A1",
  VALID_NUMBER_WARNING: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u6570\u5B57\u3002",
  ALGORITHM: "\u7B97\u6CD5",
  CHECK_ALGORITHM_WIKI: '\u4E86\u89E3\u66F4\u591A, \u8BF7\u70B9\u51FB <a href="${algo_url}">algorithm implementation</a>.',
  BASE_EASE: "\u57FA\u7840\u638C\u63E1\u7A0B\u5EA6",
  BASE_EASE_DESC: "\u6700\u5C0F\u503C130\uFF0C\u63A8\u8350\u503C\u7EA6250.",
  BASE_EASE_MIN_WARNING: "\u57FA\u7840\u638C\u63E1\u7A0B\u5EA6\u7684\u6700\u5C0F\u503C\u4E3A130\u3002",
  LAPSE_INTERVAL_CHANGE: "\u5C06\u590D\u4E60\u65F6\u6807\u6CE8\u4E3A\u201C\u8F83\u96BE\u201D\u7684\u5361\u7247\u6216\u7B14\u8BB0\u590D\u4E60\u95F4\u9694\u7F29\u77ED",
  LAPSE_INTERVAL_CHANGE_DESC: "\u65B0\u590D\u4E60\u95F4\u9694 = \u539F\u590D\u4E60\u95F4\u9694 * \u95F4\u9694\u6539\u53D8\u7CFB\u6570 / 100.",
  EASY_BONUS: "\u7B80\u5355\u5956\u52B1",
  EASY_BONUS_DESC: "\u7B80\u5355\u5956\u52B1\u8BBE\u5B9A\u201C\u8BB0\u5F97\u201D\u548C\u201C\u7B80\u5355\u201D\u5361\u7247\u6216\u7B14\u8BB0\u7684\u590D\u4E60\u95F4\u9694\u5DEE\u8DDD\uFF08\u6700\u5C0F\u503C100%\uFF09\u3002",
  EASY_BONUS_MIN_WARNING: "\u7B80\u5355\u5956\u52B1\u81F3\u5C11\u4E3A100\u3002",
  MAX_INTERVAL: "\u6700\u5927\u95F4\u9694",
  MAX_INTERVAL_DESC: "\u8BBE\u5B9A\u590D\u4E60\u7684\u6700\u5927\u95F4\u9694\u65F6\u95F4\uFF08\u9ED8\u8BA4\u503C100\u5E74\uFF09\u3002",
  MAX_INTERVAL_MIN_WARNING: "\u6700\u5927\u95F4\u9694\u81F3\u5C11\u4E3A1\u5929",
  MAX_LINK_CONTRIB: "\u6700\u5927\u94FE\u63A5\u6536\u76CA",
  MAX_LINK_CONTRIB_DESC: "\u7531\u539F\u638C\u63E1\u7A0B\u5EA6\u94FE\u63A5\u7684\u7B14\u8BB0\u7ED9\u4E0E\u7684\u6700\u5927\u52A0\u6743\u638C\u63E1\u5EA6\u6536\u76CA\u3002",
  LOGGING: "\u8BB0\u5F55\u4E2D",
  DISPLAY_DEBUG_INFO: "\u5728\u5F00\u53D1\u8005\u63A7\u5236\u53F0\u4E2D\u663E\u793A\u8C03\u8BD5\u4FE1\u606F\uFF1F",
  NOTES_REVIEW_QUEUE: "\u7B14\u8BB0\u590D\u4E60\u5E8F\u5217",
  CLOSE: "\u4E34\u8FD1",
  NEW: "\u65B0",
  YESTERDAY: "\u6628\u5929",
  TODAY: "\u4ECA\u5929",
  TOMORROW: "\u660E\u5929",
  STATS_TITLE: "\u6570\u636E",
  MONTH: "\u6708",
  QUARTER: "\u5B63",
  YEAR: "\u5E74",
  LIFETIME: "\u5168\u90E8",
  FORECAST: "\u9884\u671F",
  FORECAST_DESC: "\u5C06\u8981\u5230\u671F\u7684\u5361\u7247\u6570\u91CF",
  SCHEDULED: "\u5DF2\u6392\u671F",
  DAYS: "\u5929",
  NUMBER_OF_CARDS: "\u5361\u7247\u6570\u91CF",
  REVIEWS_PER_DAY: "\u5E73\u5747: \u590D\u4E60${avg} /\u5929",
  INTERVALS: "\u95F4\u9694",
  INTERVALS_DESC: "\u5230\u4E0B\u4E00\u6B21\u590D\u4E60\u7684\u65F6\u95F4\u95F4\u9694",
  COUNT: "\u8BA1\u6570",
  INTERVALS_SUMMARY: "\u5E73\u5747\u95F4\u9694\u65F6\u95F4: ${avg}, \u6700\u957F\u95F4\u9694\u65F6\u95F4: ${longest}",
  EASES: "Eases",
  EASES_SUMMARY: "\u5E73\u5747\u638C\u63E1\u7A0B\u5EA6: ${avgEase}",
  CARD_TYPES: "\u5361\u7247\u7C7B\u578B",
  CARD_TYPES_DESC: "\u5982\u6709\uFF0C\u5C06\u663E\u793A\u9690\u85CF\u7684\u5361\u7247",
  CARD_TYPE_NEW: "\u65B0",
  CARD_TYPE_YOUNG: "\u8F83\u65B0",
  CARD_TYPE_MATURE: "\u719F\u6089",
  CARD_TYPES_SUMMARY: "\u603B\u5361\u7247\u6570: ${totalCardsCount}"
};

// src/lang/locale/zh-tw.ts
var zh_tw_default = {};

// src/lang/helpers.ts
var localeMap = {
  ar: ar_default,
  cs: cz_default,
  da: da_default,
  de: de_default,
  en: en_default,
  "en-gb": en_gb_default,
  es: es_default,
  fr: fr_default,
  hi: hi_default,
  id: id_default,
  it: it_default,
  ja: ja_default,
  ko: ko_default,
  nl: nl_default,
  nn: no_default,
  pl: pl_default,
  pt: pt_default,
  "pt-br": pt_br_default,
  ro: ro_default,
  ru: ru_default,
  tr: tr_default,
  "zh-cn": zh_cn_default,
  "zh-tw": zh_tw_default
};
var locale = localeMap[import_obsidian.moment.locale()];
function interpolate(str, params) {
  const names2 = Object.keys(params);
  const vals = Object.values(params);
  return new Function(...names2, `return \`${str}\`;`)(...vals);
}
function t(str, params) {
  if (!locale) {
    console.error(`SRS error: Locale ${import_obsidian.moment.locale()} not found.`);
  }
  const result = locale && locale[str] || en_default[str];
  if (params) {
    return interpolate(result, params);
  }
  return result;
}

// src/settings.tsx
var DEFAULT_SETTINGS = {
  flashcardTags: ["#flashcards"],
  convertFoldersToDecks: false,
  cardCommentOnSameLine: false,
  burySiblingCards: false,
  showContextInCards: true,
  flashcardHeightPercentage: import_obsidian2.Platform.isMobile ? 100 : 80,
  flashcardWidthPercentage: import_obsidian2.Platform.isMobile ? 100 : 40,
  showFileNameInFileLink: false,
  randomizeCardOrder: true,
  convertHighlightsToClozes: true,
  convertBoldTextToClozes: false,
  singlelineCardSeparator: "::",
  singlelineReversedCardSeparator: ":::",
  multilineCardSeparator: "?",
  multilineReversedCardSeparator: "??",
  tagsToReview: ["#review"],
  noteFoldersToIgnore: [],
  openRandomNote: false,
  autoNextNote: false,
  disableFileMenuReviewOptions: false,
  maxNDaysNotesReviewQueue: 365,
  baseEase: 250,
  lapsesIntervalChange: 0.5,
  easyBonus: 1.3,
  maximumInterval: 36525,
  maxLinkFactor: 1,
  showDebugMessages: false
};
var applyDebounceTimer = 0;
function applySettingsUpdate(callback2) {
  clearTimeout(applyDebounceTimer);
  applyDebounceTimer = window.setTimeout(callback2, 512);
}
var SRSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createDiv().innerHTML = /* @__PURE__ */ (0, import_vhtml.default)("h2", null, t("SETTINGS_HEADER"));
    containerEl.createDiv().innerHTML = t("CHECK_WIKI", {
      wiki_url: "https://github.com/st3v3nmw/obsidian-spaced-repetition/wiki"
    });
    new import_obsidian2.Setting(containerEl).setName(t("FOLDERS_TO_IGNORE")).setDesc(t("FOLDERS_TO_IGNORE_DESC")).addTextArea((text) => text.setValue(this.plugin.data.settings.noteFoldersToIgnore.join("\n")).onChange((value) => {
      applySettingsUpdate(() => __async(this, null, function* () {
        this.plugin.data.settings.noteFoldersToIgnore = value.split(/\n+/).map((v) => v.trim()).filter((v) => v);
        yield this.plugin.savePluginData();
      }));
    }));
    containerEl.createDiv().innerHTML = /* @__PURE__ */ (0, import_vhtml.default)("h3", null, t("FLASHCARDS"));
    new import_obsidian2.Setting(containerEl).setName(t("FLASHCARD_TAGS")).setDesc(t("FLASHCARD_TAGS_DESC")).addTextArea((text) => text.setValue(this.plugin.data.settings.flashcardTags.join(" ")).onChange((value) => {
      applySettingsUpdate(() => __async(this, null, function* () {
        this.plugin.data.settings.flashcardTags = value.split(/\s+/);
        yield this.plugin.savePluginData();
      }));
    }));
    new import_obsidian2.Setting(containerEl).setName(t("CONVERT_FOLDERS_TO_DECKS")).setDesc(t("CONVERT_FOLDERS_TO_DECKS_DESC")).addToggle((toggle) => toggle.setValue(this.plugin.data.settings.convertFoldersToDecks).onChange((value) => __async(this, null, function* () {
      this.plugin.data.settings.convertFoldersToDecks = value;
      yield this.plugin.savePluginData();
    })));
    new import_obsidian2.Setting(containerEl).setName(t("INLINE_SCHEDULING_COMMENTS")).setDesc(t("INLINE_SCHEDULING_COMMENTS_DESC")).addToggle((toggle) => toggle.setValue(this.plugin.data.settings.cardCommentOnSameLine).onChange((value) => __async(this, null, function* () {
      this.plugin.data.settings.cardCommentOnSameLine = value;
      yield this.plugin.savePluginData();
    })));
    new import_obsidian2.Setting(containerEl).setName(t("BURY_SIBLINGS_TILL_NEXT_DAY")).setDesc(t("BURY_SIBLINGS_TILL_NEXT_DAY_DESC")).addToggle((toggle) => toggle.setValue(this.plugin.data.settings.burySiblingCards).onChange((value) => __async(this, null, function* () {
      this.plugin.data.settings.burySiblingCards = value;
      yield this.plugin.savePluginData();
    })));
    new import_obsidian2.Setting(containerEl).setName(t("SHOW_CARD_CONTEXT")).setDesc(t("SHOW_CARD_CONTEXT_DESC")).addToggle((toggle) => toggle.setValue(this.plugin.data.settings.showContextInCards).onChange((value) => __async(this, null, function* () {
      this.plugin.data.settings.showContextInCards = value;
      yield this.plugin.savePluginData();
    })));
    new import_obsidian2.Setting(containerEl).setName(t("CARD_MODAL_HEIGHT_PERCENT")).setDesc(t("CARD_MODAL_SIZE_PERCENT_DESC")).addSlider((slider) => slider.setLimits(10, 100, 5).setValue(this.plugin.data.settings.flashcardHeightPercentage).setDynamicTooltip().onChange((value) => __async(this, null, function* () {
      this.plugin.data.settings.flashcardHeightPercentage = value;
      yield this.plugin.savePluginData();
    }))).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(() => __async(this, null, function* () {
        this.plugin.data.settings.flashcardHeightPercentage = DEFAULT_SETTINGS.flashcardHeightPercentage;
        yield this.plugin.savePluginData();
        this.display();
      }));
    });
    new import_obsidian2.Setting(containerEl).setName(t("CARD_MODAL_WIDTH_PERCENT")).setDesc(t("CARD_MODAL_SIZE_PERCENT_DESC")).addSlider((slider) => slider.setLimits(10, 100, 5).setValue(this.plugin.data.settings.flashcardWidthPercentage).setDynamicTooltip().onChange((value) => __async(this, null, function* () {
      this.plugin.data.settings.flashcardWidthPercentage = value;
      yield this.plugin.savePluginData();
    }))).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(() => __async(this, null, function* () {
        this.plugin.data.settings.flashcardWidthPercentage = DEFAULT_SETTINGS.flashcardWidthPercentage;
        yield this.plugin.savePluginData();
        this.display();
      }));
    });
    new import_obsidian2.Setting(containerEl).setName(t("FILENAME_OR_OPEN_FILE")).addToggle((toggle) => toggle.setValue(this.plugin.data.settings.showFileNameInFileLink).onChange((value) => __async(this, null, function* () {
      this.plugin.data.settings.showFileNameInFileLink = value;
      yield this.plugin.savePluginData();
    })));
    new import_obsidian2.Setting(containerEl).setName(t("RANDOMIZE_CARD_ORDER")).addToggle((toggle) => toggle.setValue(this.plugin.data.settings.randomizeCardOrder).onChange((value) => __async(this, null, function* () {
      this.plugin.data.settings.randomizeCardOrder = value;
      yield this.plugin.savePluginData();
    })));
    new import_obsidian2.Setting(containerEl).setName(t("CONVERT_HIGHLIGHTS_TO_CLOZES")).addToggle((toggle) => toggle.setValue(this.plugin.data.settings.convertHighlightsToClozes).onChange((value) => __async(this, null, function* () {
      this.plugin.data.settings.convertHighlightsToClozes = value;
      yield this.plugin.savePluginData();
    })));
    new import_obsidian2.Setting(containerEl).setName(t("CONVERT_BOLD_TEXT_TO_CLOZES")).addToggle((toggle) => toggle.setValue(this.plugin.data.settings.convertBoldTextToClozes).onChange((value) => __async(this, null, function* () {
      this.plugin.data.settings.convertBoldTextToClozes = value;
      yield this.plugin.savePluginData();
    })));
    new import_obsidian2.Setting(containerEl).setName(t("INLINE_CARDS_SEPARATOR")).setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING")).addText((text) => text.setValue(this.plugin.data.settings.singlelineCardSeparator).onChange((value) => {
      applySettingsUpdate(() => __async(this, null, function* () {
        this.plugin.data.settings.singlelineCardSeparator = value;
        yield this.plugin.savePluginData();
      }));
    })).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(() => __async(this, null, function* () {
        this.plugin.data.settings.singlelineCardSeparator = DEFAULT_SETTINGS.singlelineCardSeparator;
        yield this.plugin.savePluginData();
        this.display();
      }));
    });
    new import_obsidian2.Setting(containerEl).setName(t("INLINE_REVERSED_CARDS_SEPARATOR")).setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING")).addText((text) => text.setValue(this.plugin.data.settings.singlelineReversedCardSeparator).onChange((value) => {
      applySettingsUpdate(() => __async(this, null, function* () {
        this.plugin.data.settings.singlelineReversedCardSeparator = value;
        yield this.plugin.savePluginData();
      }));
    })).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(() => __async(this, null, function* () {
        this.plugin.data.settings.singlelineReversedCardSeparator = DEFAULT_SETTINGS.singlelineReversedCardSeparator;
        yield this.plugin.savePluginData();
        this.display();
      }));
    });
    new import_obsidian2.Setting(containerEl).setName(t("MULTILINE_CARDS_SEPARATOR")).setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING")).addText((text) => text.setValue(this.plugin.data.settings.multilineCardSeparator).onChange((value) => {
      applySettingsUpdate(() => __async(this, null, function* () {
        this.plugin.data.settings.multilineCardSeparator = value;
        yield this.plugin.savePluginData();
      }));
    })).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(() => __async(this, null, function* () {
        this.plugin.data.settings.multilineCardSeparator = DEFAULT_SETTINGS.multilineCardSeparator;
        yield this.plugin.savePluginData();
        this.display();
      }));
    });
    new import_obsidian2.Setting(containerEl).setName(t("MULTILINE_REVERSED_CARDS_SEPARATOR")).setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING")).addText((text) => text.setValue(this.plugin.data.settings.multilineReversedCardSeparator).onChange((value) => {
      applySettingsUpdate(() => __async(this, null, function* () {
        this.plugin.data.settings.multilineReversedCardSeparator = value;
        yield this.plugin.savePluginData();
      }));
    })).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(() => __async(this, null, function* () {
        this.plugin.data.settings.multilineReversedCardSeparator = DEFAULT_SETTINGS.multilineReversedCardSeparator;
        yield this.plugin.savePluginData();
        this.display();
      }));
    });
    containerEl.createDiv().innerHTML = /* @__PURE__ */ (0, import_vhtml.default)("h3", null, t("NOTES"));
    new import_obsidian2.Setting(containerEl).setName(t("TAGS_TO_REVIEW")).setDesc(t("TAGS_TO_REVIEW_DESC")).addTextArea((text) => text.setValue(this.plugin.data.settings.tagsToReview.join(" ")).onChange((value) => {
      applySettingsUpdate(() => __async(this, null, function* () {
        this.plugin.data.settings.tagsToReview = value.split(/\s+/);
        yield this.plugin.savePluginData();
      }));
    }));
    new import_obsidian2.Setting(containerEl).setName(t("OPEN_RANDOM_NOTE")).setDesc(t("OPEN_RANDOM_NOTE_DESC")).addToggle((toggle) => toggle.setValue(this.plugin.data.settings.openRandomNote).onChange((value) => __async(this, null, function* () {
      this.plugin.data.settings.openRandomNote = value;
      yield this.plugin.savePluginData();
    })));
    new import_obsidian2.Setting(containerEl).setName(t("AUTO_NEXT_NOTE")).addToggle((toggle) => toggle.setValue(this.plugin.data.settings.autoNextNote).onChange((value) => __async(this, null, function* () {
      this.plugin.data.settings.autoNextNote = value;
      yield this.plugin.savePluginData();
    })));
    new import_obsidian2.Setting(containerEl).setName(t("DISABLE_FILE_MENU_REVIEW_OPTIONS")).setDesc(t("DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC")).addToggle((toggle) => toggle.setValue(this.plugin.data.settings.disableFileMenuReviewOptions).onChange((value) => __async(this, null, function* () {
      this.plugin.data.settings.disableFileMenuReviewOptions = value;
      yield this.plugin.savePluginData();
    })));
    new import_obsidian2.Setting(containerEl).setName(t("MAX_N_DAYS_REVIEW_QUEUE")).addText((text) => text.setValue(this.plugin.data.settings.maxNDaysNotesReviewQueue.toString()).onChange((value) => {
      applySettingsUpdate(() => __async(this, null, function* () {
        const numValue = Number.parseInt(value);
        if (!isNaN(numValue)) {
          if (numValue < 1) {
            new import_obsidian2.Notice(t("MIN_ONE_DAY"));
            text.setValue(this.plugin.data.settings.maxNDaysNotesReviewQueue.toString());
            return;
          }
          this.plugin.data.settings.maxNDaysNotesReviewQueue = numValue;
          yield this.plugin.savePluginData();
        } else {
          new import_obsidian2.Notice(t("VALID_NUMBER_WARNING"));
        }
      }));
    })).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(() => __async(this, null, function* () {
        this.plugin.data.settings.maxNDaysNotesReviewQueue = DEFAULT_SETTINGS.maxNDaysNotesReviewQueue;
        yield this.plugin.savePluginData();
        this.display();
      }));
    });
    containerEl.createDiv().innerHTML = /* @__PURE__ */ (0, import_vhtml.default)("h3", null, t("ALGORITHM"));
    containerEl.createDiv().innerHTML = t("CHECK_ALGORITHM_WIKI", {
      algo_url: "https://github.com/st3v3nmw/obsidian-spaced-repetition/wiki/Spaced-Repetition-Algorithm"
    });
    new import_obsidian2.Setting(containerEl).setName(t("BASE_EASE")).setDesc(t("BASE_EASE_DESC")).addText((text) => text.setValue(this.plugin.data.settings.baseEase.toString()).onChange((value) => {
      applySettingsUpdate(() => __async(this, null, function* () {
        const numValue = Number.parseInt(value);
        if (!isNaN(numValue)) {
          if (numValue < 130) {
            new import_obsidian2.Notice(t("BASE_EASE_MIN_WARNING"));
            text.setValue(this.plugin.data.settings.baseEase.toString());
            return;
          }
          this.plugin.data.settings.baseEase = numValue;
          yield this.plugin.savePluginData();
        } else {
          new import_obsidian2.Notice(t("VALID_NUMBER_WARNING"));
        }
      }));
    })).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(() => __async(this, null, function* () {
        this.plugin.data.settings.baseEase = DEFAULT_SETTINGS.baseEase;
        yield this.plugin.savePluginData();
        this.display();
      }));
    });
    new import_obsidian2.Setting(containerEl).setName(t("LAPSE_INTERVAL_CHANGE")).setDesc(t("LAPSE_INTERVAL_CHANGE_DESC")).addSlider((slider) => slider.setLimits(1, 99, 1).setValue(this.plugin.data.settings.lapsesIntervalChange * 100).setDynamicTooltip().onChange((value) => __async(this, null, function* () {
      this.plugin.data.settings.lapsesIntervalChange = value / 100;
      yield this.plugin.savePluginData();
    }))).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(() => __async(this, null, function* () {
        this.plugin.data.settings.lapsesIntervalChange = DEFAULT_SETTINGS.lapsesIntervalChange;
        yield this.plugin.savePluginData();
        this.display();
      }));
    });
    new import_obsidian2.Setting(containerEl).setName(t("EASY_BONUS")).setDesc(t("EASY_BONUS_DESC")).addText((text) => text.setValue((this.plugin.data.settings.easyBonus * 100).toString()).onChange((value) => {
      applySettingsUpdate(() => __async(this, null, function* () {
        const numValue = Number.parseInt(value) / 100;
        if (!isNaN(numValue)) {
          if (numValue < 1) {
            new import_obsidian2.Notice(t("EASY_BONUS_MIN_WARNING"));
            text.setValue((this.plugin.data.settings.easyBonus * 100).toString());
            return;
          }
          this.plugin.data.settings.easyBonus = numValue;
          yield this.plugin.savePluginData();
        } else {
          new import_obsidian2.Notice(t("VALID_NUMBER_WARNING"));
        }
      }));
    })).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(() => __async(this, null, function* () {
        this.plugin.data.settings.easyBonus = DEFAULT_SETTINGS.easyBonus;
        yield this.plugin.savePluginData();
        this.display();
      }));
    });
    new import_obsidian2.Setting(containerEl).setName(t("MAX_INTERVAL")).setDesc(t("MAX_INTERVAL_DESC")).addText((text) => text.setValue(this.plugin.data.settings.maximumInterval.toString()).onChange((value) => {
      applySettingsUpdate(() => __async(this, null, function* () {
        const numValue = Number.parseInt(value);
        if (!isNaN(numValue)) {
          if (numValue < 1) {
            new import_obsidian2.Notice(t("MAX_INTERVAL_MIN_WARNING"));
            text.setValue(this.plugin.data.settings.maximumInterval.toString());
            return;
          }
          this.plugin.data.settings.maximumInterval = numValue;
          yield this.plugin.savePluginData();
        } else {
          new import_obsidian2.Notice(t("VALID_NUMBER_WARNING"));
        }
      }));
    })).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(() => __async(this, null, function* () {
        this.plugin.data.settings.maximumInterval = DEFAULT_SETTINGS.maximumInterval;
        yield this.plugin.savePluginData();
        this.display();
      }));
    });
    new import_obsidian2.Setting(containerEl).setName(t("MAX_LINK_CONTRIB")).setDesc(t("MAX_LINK_CONTRIB_DESC")).addSlider((slider) => slider.setLimits(0, 100, 1).setValue(this.plugin.data.settings.maxLinkFactor * 100).setDynamicTooltip().onChange((value) => __async(this, null, function* () {
      this.plugin.data.settings.maxLinkFactor = value / 100;
      yield this.plugin.savePluginData();
    }))).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(() => __async(this, null, function* () {
        this.plugin.data.settings.maxLinkFactor = DEFAULT_SETTINGS.maxLinkFactor;
        yield this.plugin.savePluginData();
        this.display();
      }));
    });
    containerEl.createDiv().innerHTML = /* @__PURE__ */ (0, import_vhtml.default)("h3", null, t("LOGGING"));
    new import_obsidian2.Setting(containerEl).setName(t("DISPLAY_DEBUG_INFO")).addToggle((toggle) => toggle.setValue(this.plugin.data.settings.showDebugMessages).onChange((value) => __async(this, null, function* () {
      this.plugin.data.settings.showDebugMessages = value;
      yield this.plugin.savePluginData();
    })));
  }
};

// src/flashcard-modal.tsx
var import_obsidian3 = __toModule(require("obsidian"));
var import_vhtml2 = __toModule(require_vhtml());

// src/scheduling.ts
var ReviewResponse;
(function(ReviewResponse2) {
  ReviewResponse2[ReviewResponse2["Easy"] = 0] = "Easy";
  ReviewResponse2[ReviewResponse2["Good"] = 1] = "Good";
  ReviewResponse2[ReviewResponse2["Hard"] = 2] = "Hard";
  ReviewResponse2[ReviewResponse2["Reset"] = 3] = "Reset";
})(ReviewResponse || (ReviewResponse = {}));
var CardType;
(function(CardType2) {
  CardType2[CardType2["SingleLineBasic"] = 0] = "SingleLineBasic";
  CardType2[CardType2["SingleLineReversed"] = 1] = "SingleLineReversed";
  CardType2[CardType2["MultiLineBasic"] = 2] = "MultiLineBasic";
  CardType2[CardType2["MultiLineReversed"] = 3] = "MultiLineReversed";
  CardType2[CardType2["Cloze"] = 4] = "Cloze";
})(CardType || (CardType = {}));
function schedule(response, interval, ease, delayBeforeReview, settingsObj, dueDates) {
  delayBeforeReview = Math.max(0, Math.floor(delayBeforeReview / (24 * 3600 * 1e3)));
  if (response === 0) {
    ease += 20;
    interval = (interval + delayBeforeReview) * ease / 100;
    interval *= settingsObj.easyBonus;
  } else if (response === 1) {
    interval = (interval + delayBeforeReview / 2) * ease / 100;
  } else if (response === 2) {
    ease = Math.max(130, ease - 20);
    interval = Math.max(1, (interval + delayBeforeReview / 4) * settingsObj.lapsesIntervalChange);
  }
  if (dueDates !== void 0) {
    interval = Math.round(interval);
    if (!Object.prototype.hasOwnProperty.call(dueDates, interval)) {
      dueDates[interval] = 0;
    } else {
      if (interval > 4) {
        let fuzz = 0;
        if (interval < 7)
          fuzz = 1;
        else if (interval < 30)
          fuzz = Math.max(2, Math.floor(interval * 0.15));
        else
          fuzz = Math.max(4, Math.floor(interval * 0.05));
        const originalInterval = interval;
        outer:
          for (let i = 1; i <= fuzz; i++) {
            for (const ivl of [originalInterval - i, originalInterval + i]) {
              if (!Object.prototype.hasOwnProperty.call(dueDates, ivl)) {
                dueDates[ivl] = 0;
                interval = ivl;
                break outer;
              }
              if (dueDates[ivl] < dueDates[interval])
                interval = ivl;
            }
          }
      }
    }
    dueDates[interval]++;
  }
  interval = Math.min(interval, settingsObj.maximumInterval);
  return { interval: Math.round(interval * 10) / 10, ease };
}
function textInterval(interval, isMobile) {
  const m = Math.round(interval / 3.04375) / 10, y = Math.round(interval / 36.525) / 10;
  if (isMobile) {
    if (m < 1)
      return t("DAYS_STR_IVL_MOBILE", { interval });
    else if (y < 1)
      return t("MONTHS_STR_IVL_MOBILE", { interval: m });
    else
      return t("YEARS_STR_IVL_MOBILE", { interval: y });
  } else {
    if (m < 1)
      return t("DAYS_STR_IVL", { interval });
    else if (y < 1)
      return t("MONTHS_STR_IVL", { interval: m });
    else
      return t("YEARS_STR_IVL", { interval: y });
  }
}

// src/constants.ts
var SCHEDULING_INFO_REGEX = /^---\n((?:.*\n)*)sr-due: (.+)\nsr-interval: (\d+)\nsr-ease: (\d+)\n((?:.*\n)*)---/;
var YAML_FRONT_MATTER_REGEX = /^---\n((?:.*\n)*?)---/;
var MULTI_SCHEDULING_EXTRACTOR = /!([\d-]+),(\d+),(\d+)/gm;
var LEGACY_SCHEDULING_EXTRACTOR = /<!--SR:([\d-]+),(\d+),(\d+)-->/gm;
var IMAGE_FORMATS = ["jpg", "jpeg", "gif", "png", "svg"];
var AUDIO_FORMATS = ["mp3", "webm", "m4a", "wav"];
var VIDEO_FORMATS = ["mp4", "mkv", "avi", "mov"];
var COLLAPSE_ICON = '<svg viewBox="0 0 100 100" width="8" height="8" class="right-triangle"><path fill="currentColor" stroke="currentColor" d="M94.9,20.8c-1.4-2.5-4.1-4.1-7.1-4.1H12.2c-3,0-5.7,1.6-7.1,4.1c-1.3,2.4-1.2,5.2,0.2,7.6L43.1,88c1.5,2.3,4,3.7,6.9,3.7 s5.4-1.4,6.9-3.7l37.8-59.6C96.1,26,96.2,23.2,94.9,20.8L94.9,20.8z"></path></svg>';

// src/utils.ts
var getKeysPreserveType = Object.keys;
var escapeRegexString = (text) => text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
function cyrb53(str, seed = 0) {
  let h12 = 3735928559 ^ seed, h23 = 1103547991 ^ seed;
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h12 = Math.imul(h12 ^ ch, 2654435761);
    h23 = Math.imul(h23 ^ ch, 1597334677);
  }
  h12 = Math.imul(h12 ^ h12 >>> 16, 2246822507) ^ Math.imul(h23 ^ h23 >>> 13, 3266489909);
  h23 = Math.imul(h23 ^ h23 >>> 16, 2246822507) ^ Math.imul(h12 ^ h12 >>> 13, 3266489909);
  return (4294967296 * (2097151 & h23) + (h12 >>> 0)).toString(16);
}

// src/flashcard-modal.tsx
var FlashcardModalMode;
(function(FlashcardModalMode2) {
  FlashcardModalMode2[FlashcardModalMode2["DecksList"] = 0] = "DecksList";
  FlashcardModalMode2[FlashcardModalMode2["Front"] = 1] = "Front";
  FlashcardModalMode2[FlashcardModalMode2["Back"] = 2] = "Back";
  FlashcardModalMode2[FlashcardModalMode2["Closed"] = 3] = "Closed";
})(FlashcardModalMode || (FlashcardModalMode = {}));
var FlashcardModal = class extends import_obsidian3.Modal {
  constructor(app, plugin, ignoreStats = false) {
    super(app);
    this.plugin = plugin;
    this.ignoreStats = ignoreStats;
    this.titleEl.setText(t("DECKS"));
    if (import_obsidian3.Platform.isMobile) {
      this.contentEl.style.display = "block";
    }
    this.modalEl.style.height = this.plugin.data.settings.flashcardHeightPercentage + "%";
    this.modalEl.style.width = this.plugin.data.settings.flashcardWidthPercentage + "%";
    this.contentEl.style.position = "relative";
    this.contentEl.style.height = "92%";
    this.contentEl.addClass("sr-modal-content");
    document.body.onkeydown = (e) => {
      if (this.mode !== 0) {
        if (this.mode !== 3 && e.code === "KeyS") {
          this.currentDeck.deleteFlashcardAtIndex(this.currentCardIdx, this.currentCard.isDue);
          this.burySiblingCards(false);
          this.currentDeck.nextCard(this);
        } else if (this.mode === 1 && (e.code === "Space" || e.code === "Enter")) {
          this.showAnswer();
        } else if (this.mode === 2) {
          if (e.code === "Numpad1" || e.code === "Digit1") {
            this.processReview(ReviewResponse.Hard);
          } else if (e.code === "Numpad2" || e.code === "Digit2" || e.code === "Space") {
            this.processReview(ReviewResponse.Good);
          } else if (e.code === "Numpad3" || e.code === "Digit3") {
            this.processReview(ReviewResponse.Easy);
          } else if (e.code === "Numpad0" || e.code === "Digit0") {
            this.processReview(ReviewResponse.Reset);
          }
        }
      }
    };
  }
  onOpen() {
    this.decksList();
  }
  onClose() {
    this.mode = 3;
  }
  decksList() {
    this.mode = 0;
    this.titleEl.setText(t("DECKS"));
    this.titleEl.innerHTML += /* @__PURE__ */ (0, import_vhtml2.default)("p", {
      style: "margin:0px;line-height:12px;"
    }, /* @__PURE__ */ (0, import_vhtml2.default)("span", {
      style: "background-color:#4caf50;color:#ffffff;",
      "aria-label": t("DUE_CARDS"),
      class: "tag-pane-tag-count tree-item-flair"
    }, this.plugin.deckTree.dueFlashcardsCount.toString()), /* @__PURE__ */ (0, import_vhtml2.default)("span", {
      style: "background-color:#2196f3;",
      "aria-label": t("NEW_CARDS"),
      class: "tag-pane-tag-count tree-item-flair sr-deck-counts"
    }, this.plugin.deckTree.newFlashcardsCount.toString()), /* @__PURE__ */ (0, import_vhtml2.default)("span", {
      style: "background-color:#ff7043;",
      "aria-label": t("TOTAL_CARDS"),
      class: "tag-pane-tag-count tree-item-flair sr-deck-counts"
    }, this.plugin.deckTree.totalFlashcards.toString()));
    this.contentEl.innerHTML = "";
    this.contentEl.setAttribute("id", "sr-flashcard-view");
    for (const deck of this.plugin.deckTree.subdecks) {
      deck.render(this.contentEl, this);
    }
  }
  setupCardsView() {
    this.contentEl.innerHTML = "";
    this.fileLinkView = this.contentEl.createDiv("sr-link");
    this.fileLinkView.setText(t("EDIT_LATER"));
    if (this.plugin.data.settings.showFileNameInFileLink) {
      this.fileLinkView.setAttribute("aria-label", t("EDIT_LATER"));
    }
    this.fileLinkView.addEventListener("click", () => __async(this, null, function* () {
      const activeLeaf = this.plugin.app.workspace.activeLeaf;
      if (this.plugin.app.workspace.getActiveFile() === null)
        yield activeLeaf.openFile(this.currentCard.note);
      else {
        const newLeaf = this.plugin.app.workspace.createLeafBySplit(activeLeaf, "vertical", false);
        yield newLeaf.openFile(this.currentCard.note, { active: true });
      }
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
      activeView.editor.setCursor({
        line: this.currentCard.lineNo,
        ch: 0
      });
      this.currentDeck.deleteFlashcardAtIndex(this.currentCardIdx, this.currentCard.isDue);
      this.burySiblingCards(false);
      this.currentDeck.nextCard(this);
    }));
    this.resetLinkView = this.contentEl.createDiv("sr-link");
    this.resetLinkView.setText(t("RESET_CARD_PROGRESS"));
    this.resetLinkView.addEventListener("click", () => {
      this.processReview(ReviewResponse.Reset);
    });
    this.resetLinkView.style.float = "right";
    if (this.plugin.data.settings.showContextInCards) {
      this.contextView = this.contentEl.createDiv();
      this.contextView.setAttribute("id", "sr-context");
    }
    this.flashcardView = this.contentEl.createDiv("div");
    this.flashcardView.setAttribute("id", "sr-flashcard-view");
    this.responseDiv = this.contentEl.createDiv("sr-response");
    this.hardBtn = document.createElement("button");
    this.hardBtn.setAttribute("id", "sr-hard-btn");
    this.hardBtn.setText(t("HARD"));
    this.hardBtn.addEventListener("click", () => {
      this.processReview(ReviewResponse.Hard);
    });
    this.responseDiv.appendChild(this.hardBtn);
    this.goodBtn = document.createElement("button");
    this.goodBtn.setAttribute("id", "sr-good-btn");
    this.goodBtn.setText(t("GOOD"));
    this.goodBtn.addEventListener("click", () => {
      this.processReview(ReviewResponse.Good);
    });
    this.responseDiv.appendChild(this.goodBtn);
    this.easyBtn = document.createElement("button");
    this.easyBtn.setAttribute("id", "sr-easy-btn");
    this.easyBtn.setText(t("EASY"));
    this.easyBtn.addEventListener("click", () => {
      this.processReview(ReviewResponse.Easy);
    });
    this.responseDiv.appendChild(this.easyBtn);
    this.responseDiv.style.display = "none";
    this.answerBtn = this.contentEl.createDiv();
    this.answerBtn.setAttribute("id", "sr-show-answer");
    this.answerBtn.setText(t("SHOW_ANSWER"));
    this.answerBtn.addEventListener("click", () => {
      this.showAnswer();
    });
    if (this.ignoreStats) {
      this.goodBtn.style.display = "none";
      this.responseDiv.addClass("sr-ignorestats-response");
      this.easyBtn.addClass("sr-ignorestats-btn");
      this.hardBtn.addClass("sr-ignorestats-btn");
    }
  }
  showAnswer() {
    this.mode = 2;
    this.answerBtn.style.display = "none";
    this.responseDiv.style.display = "grid";
    if (this.currentCard.isDue) {
      this.resetLinkView.style.display = "inline-block";
    }
    if (this.currentCard.cardType !== CardType.Cloze) {
      const hr = document.createElement("hr");
      hr.setAttribute("id", "sr-hr-card-divide");
      this.flashcardView.appendChild(hr);
    } else {
      this.flashcardView.innerHTML = "";
    }
    this.renderMarkdownWrapper(this.currentCard.back, this.flashcardView);
  }
  processReview(response) {
    return __async(this, null, function* () {
      if (this.ignoreStats) {
        if (response == ReviewResponse.Easy) {
          this.currentDeck.deleteFlashcardAtIndex(this.currentCardIdx, this.currentCard.isDue);
        }
        this.currentDeck.nextCard(this);
        return;
      }
      let interval, ease, due;
      this.currentDeck.deleteFlashcardAtIndex(this.currentCardIdx, this.currentCard.isDue);
      if (response !== ReviewResponse.Reset) {
        let schedObj;
        if (this.currentCard.isDue) {
          schedObj = schedule(response, this.currentCard.interval, this.currentCard.ease, this.currentCard.delayBeforeReview, this.plugin.data.settings, this.plugin.dueDatesFlashcards);
        } else {
          let initial_ease = this.plugin.data.settings.baseEase;
          if (Object.prototype.hasOwnProperty.call(this.plugin.easeByPath, this.currentCard.note.path)) {
            initial_ease = Math.round(this.plugin.easeByPath[this.currentCard.note.path]);
          }
          schedObj = schedule(response, 1, initial_ease, 0, this.plugin.data.settings, this.plugin.dueDatesFlashcards);
          interval = schedObj.interval;
          ease = schedObj.ease;
        }
        interval = schedObj.interval;
        ease = schedObj.ease;
        due = window.moment(Date.now() + interval * 24 * 3600 * 1e3);
      } else {
        this.currentCard.interval = 1;
        this.currentCard.ease = this.plugin.data.settings.baseEase;
        if (this.currentCard.isDue) {
          this.currentDeck.dueFlashcards.push(this.currentCard);
        } else {
          this.currentDeck.newFlashcards.push(this.currentCard);
        }
        due = window.moment(Date.now());
        new import_obsidian3.Notice(t("CARD_PROGRESS_RESET"));
        this.currentDeck.nextCard(this);
        return;
      }
      const dueString = due.format("YYYY-MM-DD");
      let fileText = yield this.app.vault.read(this.currentCard.note);
      const replacementRegex = new RegExp(escapeRegexString(this.currentCard.cardText), "gm");
      let sep = this.plugin.data.settings.cardCommentOnSameLine ? " " : "\n";
      if (this.currentCard.cardText.endsWith("```") && sep !== "\n") {
        sep = "\n";
      }
      if (this.currentCard.cardText.lastIndexOf("<!--SR:") === -1) {
        this.currentCard.cardText = this.currentCard.cardText + sep + `<!--SR:!${dueString},${interval},${ease}-->`;
      } else {
        let scheduling = [
          ...this.currentCard.cardText.matchAll(MULTI_SCHEDULING_EXTRACTOR)
        ];
        if (scheduling.length === 0) {
          scheduling = [...this.currentCard.cardText.matchAll(LEGACY_SCHEDULING_EXTRACTOR)];
        }
        const currCardSched = ["0", dueString, interval.toString(), ease.toString()];
        if (this.currentCard.isDue) {
          scheduling[this.currentCard.siblingIdx] = currCardSched;
        } else {
          scheduling.push(currCardSched);
        }
        this.currentCard.cardText = this.currentCard.cardText.replace(/<!--SR:.+-->/gm, "");
        this.currentCard.cardText += "<!--SR:";
        for (let i = 0; i < scheduling.length; i++) {
          this.currentCard.cardText += `!${scheduling[i][1]},${scheduling[i][2]},${scheduling[i][3]}`;
        }
        this.currentCard.cardText += "-->";
      }
      fileText = fileText.replace(replacementRegex, () => this.currentCard.cardText);
      for (const sibling of this.currentCard.siblings) {
        sibling.cardText = this.currentCard.cardText;
      }
      if (this.plugin.data.settings.burySiblingCards) {
        this.burySiblingCards(true);
      }
      yield this.app.vault.modify(this.currentCard.note, fileText);
      this.currentDeck.nextCard(this);
    });
  }
  burySiblingCards(tillNextDay) {
    return __async(this, null, function* () {
      if (tillNextDay) {
        this.plugin.data.buryList.push(cyrb53(this.currentCard.cardText));
        yield this.plugin.savePluginData();
      }
      for (const sibling of this.currentCard.siblings) {
        const dueIdx = this.currentDeck.dueFlashcards.indexOf(sibling);
        const newIdx = this.currentDeck.newFlashcards.indexOf(sibling);
        if (dueIdx !== -1) {
          this.currentDeck.deleteFlashcardAtIndex(dueIdx, this.currentDeck.dueFlashcards[dueIdx].isDue);
        } else if (newIdx !== -1) {
          this.currentDeck.deleteFlashcardAtIndex(newIdx, this.currentDeck.newFlashcards[newIdx].isDue);
        }
      }
    });
  }
  renderMarkdownWrapper(markdownString, containerEl, recursiveDepth = 0) {
    return __async(this, null, function* () {
      if (recursiveDepth > 4)
        return;
      import_obsidian3.MarkdownRenderer.renderMarkdown(markdownString, containerEl, this.currentCard.note.path, this.plugin);
      containerEl.findAll(".internal-embed").forEach((el) => {
        const link2 = this.parseLink(el.getAttribute("src"));
        if (!link2.target) {
          el.innerText = link2.text;
        } else if (link2.target instanceof import_obsidian3.TFile) {
          if (link2.target.extension !== "md") {
            this.embedMediaFile(el, link2.target);
          } else {
            el.innerText = "";
            this.renderTransclude(el, link2, recursiveDepth);
          }
        }
      });
    });
  }
  parseLink(src) {
    const linkComponentsRegex = /^(?<file>[^#^]+)?(?:#(?!\^)(?<heading>.+)|#\^(?<blockId>.+)|#)?$/;
    const matched = typeof src === "string" && src.match(linkComponentsRegex);
    const file = matched.groups.file || this.currentCard.note.path;
    const target = this.plugin.app.metadataCache.getFirstLinkpathDest(file, this.currentCard.note.path);
    return {
      text: matched[0],
      file: matched.groups.file,
      heading: matched.groups.heading,
      blockId: matched.groups.blockId,
      target
    };
  }
  embedMediaFile(el, target) {
    el.innerText = "";
    if (IMAGE_FORMATS.includes(target.extension)) {
      el.createEl("img", {
        attr: {
          src: this.plugin.app.vault.getResourcePath(target)
        }
      }, (img) => {
        if (el.hasAttribute("width"))
          img.setAttribute("width", el.getAttribute("width"));
        else
          img.setAttribute("width", "100%");
        if (el.hasAttribute("alt"))
          img.setAttribute("alt", el.getAttribute("alt"));
        el.addEventListener("click", (ev) => ev.target.style.minWidth = ev.target.style.minWidth === "100%" ? null : "100%");
      });
      el.addClasses(["image-embed", "is-loaded"]);
    } else if (AUDIO_FORMATS.includes(target.extension) || VIDEO_FORMATS.includes(target.extension)) {
      el.createEl(AUDIO_FORMATS.includes(target.extension) ? "audio" : "video", {
        attr: {
          controls: "",
          src: this.plugin.app.vault.getResourcePath(target)
        }
      }, (audio) => {
        if (el.hasAttribute("alt"))
          audio.setAttribute("alt", el.getAttribute("alt"));
      });
      el.addClasses(["media-embed", "is-loaded"]);
    } else {
      el.innerText = target.path;
    }
  }
  renderTransclude(el, link2, recursiveDepth) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      const cache = this.app.metadataCache.getCache(link2.target.path);
      const text = yield this.app.vault.cachedRead(link2.target);
      let blockText;
      if (link2.heading) {
        const clean = (s) => s.replace(/[\W\s]/g, "");
        const headingIndex = (_a = cache.headings) == null ? void 0 : _a.findIndex((h4) => clean(h4.heading) === clean(link2.heading));
        const heading = cache.headings[headingIndex];
        const startAt = heading.position.start.offset;
        const endAt = ((_d = (_c = (_b = cache.headings.slice(headingIndex + 1).find((h4) => h4.level <= heading.level)) == null ? void 0 : _b.position) == null ? void 0 : _c.start) == null ? void 0 : _d.offset) || text.length;
        blockText = text.substring(startAt, endAt);
      } else if (link2.blockId) {
        const block = cache.blocks[link2.blockId];
        const startAt = block.position.start.offset;
        const endAt = block.position.end.offset;
        blockText = text.substring(startAt, endAt);
      } else {
        blockText = text;
      }
      this.renderMarkdownWrapper(blockText, el, recursiveDepth + 1);
    });
  }
};
var Deck = class {
  constructor(deckName, parent) {
    this.newFlashcardsCount = 0;
    this.dueFlashcardsCount = 0;
    this.totalFlashcards = 0;
    this.deckName = deckName;
    this.newFlashcards = [];
    this.newFlashcardsCount = 0;
    this.dueFlashcards = [];
    this.dueFlashcardsCount = 0;
    this.totalFlashcards = 0;
    this.subdecks = [];
    this.parent = parent;
  }
  createDeck(deckPath) {
    if (deckPath.length === 0) {
      return;
    }
    const deckName = deckPath.shift();
    for (const deck2 of this.subdecks) {
      if (deckName === deck2.deckName) {
        deck2.createDeck(deckPath);
        return;
      }
    }
    const deck = new Deck(deckName, this);
    this.subdecks.push(deck);
    deck.createDeck(deckPath);
  }
  insertFlashcard(deckPath, cardObj) {
    if (cardObj.isDue) {
      this.dueFlashcardsCount++;
    } else {
      this.newFlashcardsCount++;
    }
    this.totalFlashcards++;
    if (deckPath.length === 0) {
      if (cardObj.isDue) {
        this.dueFlashcards.push(cardObj);
      } else {
        this.newFlashcards.push(cardObj);
      }
      return;
    }
    const deckName = deckPath.shift();
    for (const deck of this.subdecks) {
      if (deckName === deck.deckName) {
        deck.insertFlashcard(deckPath, cardObj);
        return;
      }
    }
  }
  countFlashcard(deckPath, n = 1) {
    this.totalFlashcards += n;
    const deckName = deckPath.shift();
    for (const deck of this.subdecks) {
      if (deckName === deck.deckName) {
        deck.countFlashcard(deckPath, n);
        return;
      }
    }
  }
  deleteFlashcardAtIndex(index, cardIsDue) {
    if (cardIsDue) {
      this.dueFlashcards.splice(index, 1);
      this.dueFlashcardsCount--;
    } else {
      this.newFlashcards.splice(index, 1);
      this.newFlashcardsCount--;
    }
    let deck = this.parent;
    while (deck !== null) {
      if (cardIsDue) {
        deck.dueFlashcardsCount--;
      } else {
        deck.newFlashcardsCount--;
      }
      deck = deck.parent;
    }
  }
  sortSubdecksList() {
    this.subdecks.sort((a, b) => {
      if (a.deckName < b.deckName) {
        return -1;
      } else if (a.deckName > b.deckName) {
        return 1;
      }
      return 0;
    });
    for (const deck of this.subdecks) {
      deck.sortSubdecksList();
    }
  }
  render(containerEl, modal) {
    const deckView = containerEl.createDiv("tree-item");
    const deckViewSelf = deckView.createDiv("tree-item-self tag-pane-tag is-clickable");
    let collapsed = true;
    let collapseIconEl = null;
    if (this.subdecks.length > 0) {
      collapseIconEl = deckViewSelf.createDiv("tree-item-icon collapse-icon");
      collapseIconEl.innerHTML = COLLAPSE_ICON;
      collapseIconEl.childNodes[0].style.transform = "rotate(-90deg)";
    }
    const deckViewInner = deckViewSelf.createDiv("tree-item-inner");
    deckViewInner.addEventListener("click", () => {
      modal.currentDeck = this;
      modal.checkDeck = this.parent;
      modal.setupCardsView();
      this.nextCard(modal);
    });
    const deckViewInnerText = deckViewInner.createDiv("tag-pane-tag-text");
    deckViewInnerText.innerHTML += /* @__PURE__ */ (0, import_vhtml2.default)("span", {
      class: "tag-pane-tag-self"
    }, this.deckName);
    const deckViewOuter = deckViewSelf.createDiv("tree-item-flair-outer");
    deckViewOuter.innerHTML += /* @__PURE__ */ (0, import_vhtml2.default)("span", null, /* @__PURE__ */ (0, import_vhtml2.default)("span", {
      style: "background-color:#4caf50;",
      class: "tag-pane-tag-count tree-item-flair sr-deck-counts"
    }, this.dueFlashcardsCount.toString()), /* @__PURE__ */ (0, import_vhtml2.default)("span", {
      style: "background-color:#2196f3;",
      class: "tag-pane-tag-count tree-item-flair sr-deck-counts"
    }, this.newFlashcardsCount.toString()), /* @__PURE__ */ (0, import_vhtml2.default)("span", {
      style: "background-color:#ff7043;",
      class: "tag-pane-tag-count tree-item-flair sr-deck-counts"
    }, this.totalFlashcards.toString()));
    const deckViewChildren = deckView.createDiv("tree-item-children");
    deckViewChildren.style.display = "none";
    if (this.subdecks.length > 0) {
      collapseIconEl.addEventListener("click", () => {
        if (collapsed) {
          collapseIconEl.childNodes[0].style.transform = "";
          deckViewChildren.style.display = "block";
        } else {
          collapseIconEl.childNodes[0].style.transform = "rotate(-90deg)";
          deckViewChildren.style.display = "none";
        }
        collapsed = !collapsed;
      });
    }
    for (const deck of this.subdecks) {
      deck.render(deckViewChildren, modal);
    }
  }
  nextCard(modal) {
    if (this.newFlashcards.length + this.dueFlashcards.length === 0) {
      if (this.dueFlashcardsCount + this.newFlashcardsCount > 0) {
        for (const deck of this.subdecks) {
          if (deck.dueFlashcardsCount + deck.newFlashcardsCount > 0) {
            modal.currentDeck = deck;
            deck.nextCard(modal);
            return;
          }
        }
      }
      if (this.parent == modal.checkDeck) {
        modal.decksList();
      } else {
        this.parent.nextCard(modal);
      }
      return;
    }
    modal.responseDiv.style.display = "none";
    modal.resetLinkView.style.display = "none";
    modal.titleEl.setText(`${this.deckName}: ${this.dueFlashcardsCount + this.newFlashcardsCount}`);
    modal.answerBtn.style.display = "initial";
    modal.flashcardView.innerHTML = "";
    modal.mode = 1;
    let interval = 1, ease = modal.plugin.data.settings.baseEase, delayBeforeReview = 0;
    if (this.dueFlashcards.length > 0) {
      if (modal.plugin.data.settings.randomizeCardOrder) {
        modal.currentCardIdx = Math.floor(Math.random() * this.dueFlashcards.length);
      } else {
        modal.currentCardIdx = 0;
      }
      modal.currentCard = this.dueFlashcards[modal.currentCardIdx];
      modal.renderMarkdownWrapper(modal.currentCard.front, modal.flashcardView);
      interval = modal.currentCard.interval;
      ease = modal.currentCard.ease;
      delayBeforeReview = modal.currentCard.delayBeforeReview;
    } else if (this.newFlashcards.length > 0) {
      if (modal.plugin.data.settings.randomizeCardOrder) {
        const pickedCardIdx = Math.floor(Math.random() * this.newFlashcards.length);
        modal.currentCardIdx = pickedCardIdx;
        const pickedCard = this.newFlashcards[pickedCardIdx];
        let idx = pickedCardIdx;
        while (idx >= 0 && pickedCard.siblings.includes(this.newFlashcards[idx])) {
          if (!this.newFlashcards[idx].isDue) {
            modal.currentCardIdx = idx;
          }
          idx--;
        }
      } else {
        modal.currentCardIdx = 0;
      }
      modal.currentCard = this.newFlashcards[modal.currentCardIdx];
      modal.renderMarkdownWrapper(modal.currentCard.front, modal.flashcardView);
      if (Object.prototype.hasOwnProperty.call(modal.plugin.easeByPath, modal.currentCard.note.path)) {
        ease = modal.plugin.easeByPath[modal.currentCard.note.path];
      }
    }
    const hardInterval = schedule(ReviewResponse.Hard, interval, ease, delayBeforeReview, modal.plugin.data.settings).interval;
    const goodInterval = schedule(ReviewResponse.Good, interval, ease, delayBeforeReview, modal.plugin.data.settings).interval;
    const easyInterval = schedule(ReviewResponse.Easy, interval, ease, delayBeforeReview, modal.plugin.data.settings).interval;
    if (modal.ignoreStats) {
      modal.hardBtn.setText(`${t("HARD")}`);
      modal.easyBtn.setText(`${t("EASY")}`);
    } else if (import_obsidian3.Platform.isMobile) {
      modal.hardBtn.setText(textInterval(hardInterval, true));
      modal.goodBtn.setText(textInterval(goodInterval, true));
      modal.easyBtn.setText(textInterval(easyInterval, true));
    } else {
      modal.hardBtn.setText(`${t("HARD")} - ${textInterval(hardInterval, false)}`);
      modal.goodBtn.setText(`${t("GOOD")} - ${textInterval(goodInterval, false)}`);
      modal.easyBtn.setText(`${t("EASY")} - ${textInterval(easyInterval, false)}`);
    }
    if (modal.plugin.data.settings.showContextInCards)
      modal.contextView.setText(modal.currentCard.context);
    if (modal.plugin.data.settings.showFileNameInFileLink)
      modal.fileLinkView.setText(modal.currentCard.note.basename);
  }
};

// src/stats-modal.tsx
var import_obsidian4 = __toModule(require("obsidian"));
var import_vhtml3 = __toModule(require_vhtml());

// node_modules/chart.js/dist/chunks/helpers.segment.js
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg, updateFn) {
  const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
  let ticking = false;
  let args = [];
  return function(...rest) {
    args = updateArgs(rest);
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, args);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function noop() {
}
var uid = function() {
  let id = 0;
  return function() {
    return id++;
  };
}();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.substr(0, 7) === "[object" && type.substr(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
var isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone$1(source) {
  if (isArray(source)) {
    return source.map(clone$1);
  }
  if (isObject(source)) {
    const target = Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone$1(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone$1(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [source];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  for (let i = 0; i < ilen; ++i) {
    source = sources[i];
    if (!isObject(source)) {
      continue;
    }
    const keys = Object.keys(source);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, source, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, { merger: _mergerIf });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone$1(sval);
  }
}
var emptyString = "";
var dot = ".";
function indexOfDotOrLength(key, start) {
  const idx = key.indexOf(dot, start);
  return idx === -1 ? key.length : idx;
}
function resolveObjectKey(obj, key) {
  if (key === emptyString) {
    return obj;
  }
  let pos = 0;
  let idx = indexOfDotOrLength(key, pos);
  while (obj && idx > pos) {
    obj = obj[key.substr(pos, idx - pos)];
    pos = idx + 1;
    idx = indexOfDotOrLength(key, pos);
  }
  return obj;
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
var atEdge = (t2) => t2 === 0 || t2 === 1;
var elasticIn = (t2, s, p) => -(Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s) * TAU / p));
var elasticOut = (t2, s, p) => Math.pow(2, -10 * t2) * Math.sin((t2 - s) * TAU / p) + 1;
var effects = {
  linear: (t2) => t2,
  easeInQuad: (t2) => t2 * t2,
  easeOutQuad: (t2) => -t2 * (t2 - 2),
  easeInOutQuad: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 : -0.5 * (--t2 * (t2 - 2) - 1),
  easeInCubic: (t2) => t2 * t2 * t2,
  easeOutCubic: (t2) => (t2 -= 1) * t2 * t2 + 1,
  easeInOutCubic: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 + 2),
  easeInQuart: (t2) => t2 * t2 * t2 * t2,
  easeOutQuart: (t2) => -((t2 -= 1) * t2 * t2 * t2 - 1),
  easeInOutQuart: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2),
  easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
  easeOutQuint: (t2) => (t2 -= 1) * t2 * t2 * t2 * t2 + 1,
  easeInOutQuint: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2),
  easeInSine: (t2) => -Math.cos(t2 * HALF_PI) + 1,
  easeOutSine: (t2) => Math.sin(t2 * HALF_PI),
  easeInOutSine: (t2) => -0.5 * (Math.cos(PI * t2) - 1),
  easeInExpo: (t2) => t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1)),
  easeOutExpo: (t2) => t2 === 1 ? 1 : -Math.pow(2, -10 * t2) + 1,
  easeInOutExpo: (t2) => atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * Math.pow(2, 10 * (t2 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t2 * 2 - 1)) + 2),
  easeInCirc: (t2) => t2 >= 1 ? t2 : -(Math.sqrt(1 - t2 * t2) - 1),
  easeOutCirc: (t2) => Math.sqrt(1 - (t2 -= 1) * t2),
  easeInOutCirc: (t2) => (t2 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1),
  easeInElastic: (t2) => atEdge(t2) ? t2 : elasticIn(t2, 0.075, 0.3),
  easeOutElastic: (t2) => atEdge(t2) ? t2 : elasticOut(t2, 0.075, 0.3),
  easeInOutElastic(t2) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * elasticIn(t2 * 2, s, p) : 0.5 + 0.5 * elasticOut(t2 * 2 - 1, s, p);
  },
  easeInBack(t2) {
    const s = 1.70158;
    return t2 * t2 * ((s + 1) * t2 - s);
  },
  easeOutBack(t2) {
    const s = 1.70158;
    return (t2 -= 1) * t2 * ((s + 1) * t2 + s) + 1;
  },
  easeInOutBack(t2) {
    let s = 1.70158;
    if ((t2 /= 0.5) < 1) {
      return 0.5 * (t2 * t2 * (((s *= 1.525) + 1) * t2 - s));
    }
    return 0.5 * ((t2 -= 2) * t2 * (((s *= 1.525) + 1) * t2 + s) + 2);
  },
  easeInBounce: (t2) => 1 - effects.easeOutBounce(1 - t2),
  easeOutBounce(t2) {
    const m = 7.5625;
    const d = 2.75;
    if (t2 < 1 / d) {
      return m * t2 * t2;
    }
    if (t2 < 2 / d) {
      return m * (t2 -= 1.5 / d) * t2 + 0.75;
    }
    if (t2 < 2.5 / d) {
      return m * (t2 -= 2.25 / d) * t2 + 0.9375;
    }
    return m * (t2 -= 2.625 / d) * t2 + 0.984375;
  },
  easeInOutBounce: (t2) => t2 < 0.5 ? effects.easeInBounce(t2 * 2) * 0.5 : effects.easeOutBounce(t2 * 2 - 1) * 0.5 + 0.5
};
var map = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = "0123456789ABCDEF";
var h1 = (b) => hex[b & 15];
var h22 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
var eq = (b) => (b & 240) >> 4 === (b & 15);
function isShort(v) {
  return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
}
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map[str[1]] * 17,
        g: 255 & map[str[2]] * 17,
        b: 255 & map[str[3]] * 17,
        a: len === 5 ? map[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map[str[1]] << 4 | map[str[2]],
        g: map[str[3]] << 4 | map[str[4]],
        b: map[str[5]] << 4 | map[str[6]],
        a: len === 9 ? map[str[7]] << 4 | map[str[8]] : 255
      };
    }
  }
  return ret;
}
function hexString(v) {
  var f = isShort(v) ? h1 : h22;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : "") : v;
}
function round(v) {
  return v + 0.5 | 0;
}
var lim = (v, l, h4) => Math.max(Math.min(v, h4), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = 255 & (m[8] ? p2b(v) : v * 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : r);
  g = 255 & (m[4] ? p2b(g) : g);
  b = 255 & (m[6] ? p2b(b) : b);
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h4, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h4 / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h4, s, v) {
  const f = (n, k = (n + h4 / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h4, w, b) {
  const rgb = hsl2rgbn(h4, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h4, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h4 = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
    h4 = h4 * 60 + 0.5;
  }
  return [h4 | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h4, s, l) {
  return calln(hsl2rgbn, h4, s, l);
}
function hwb2rgb(h4, w, b) {
  return calln(hwb2rgbn, h4, w, b);
}
function hsv2rgb(h4, s, v) {
  return calln(hsv2rgbn, h4, s, v);
}
function hue(h4) {
  return (h4 % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h4 = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb(h4, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb(h4, p1, p2);
  } else {
    v = hsl2rgb(h4, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate(v, deg) {
  var h4 = rgb2hsl(v);
  h4[0] = hue(h4[0] + deg);
  h4 = hsl2rgb(h4);
  v.r = h4[0];
  v.g = h4[1];
  v.b = h4[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h4 = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255 ? `hsla(${h4}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h4}, ${s}%, ${l}%)`;
}
var map$1 = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names);
  const tkeys = Object.keys(map$1);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map$1[k]);
    }
    k = parseInt(names[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
var names$1;
function nameParse(str) {
  if (!names$1) {
    names$1 = unpack();
    names$1.transparent = [0, 0, 0, 0];
  }
  const a = names$1[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : this._rgb;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : this._rgb;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : this._rgb;
  }
  mix(color2, weight) {
    const me = this;
    if (color2) {
      const c1 = me.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      me.rgb = c1;
    }
    return me;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};
function index_esm(input) {
  return new Color(input);
}
var isPatternOrGradient = (value) => value instanceof CanvasGradient || value instanceof CanvasPattern;
function color(value) {
  return isPatternOrGradient(value) ? value : index_esm(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
}
var overrides = Object.create(null);
var descriptors = Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
};
var defaults = new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
});
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  let type, xOffset, yOffset, size, cornerRadius;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      ctx.arc(x, y, radius, 0, TAU);
      ctx.closePath();
      break;
    case "triangle":
      ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        ctx.rect(x - size, y - size, 2 * size, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + yOffset, y - xOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      break;
    case "star":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      rad += QUARTER_PI;
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      break;
    case "line":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [text];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += font.lineHeight;
  }
  ctx.restore();
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h: h4, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
  ctx.lineTo(x, y + h4 - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h4 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h4);
  ctx.arc(x + w - radius.bottomRight, y + h4 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
var LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
var FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
var numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, { top: "y", right: "x", bottom: "y", left: "x" });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = "";
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index !== void 0 && isArray(value)) {
      value = value[index % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index) => table[index] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return { lo, hi };
}
var _lookupByKey = (table, key, value) => _lookup(table, value, (index) => table[index][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index) => table[index][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [listener]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index = listeners.indexOf(listener);
  if (index !== -1) {
    listeners.splice(index, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = new Set();
  let i, ilen;
  for (i = 0, ilen = items.length; i < ilen; ++i) {
    set2.add(items[i]);
  }
  if (set2.size === ilen) {
    return items;
  }
  return Array.from(set2);
}
function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
  if (!defined(fallback)) {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: rootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = { scriptable: true, indexable: true }) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, value, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  value = value(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (defined(_context.index) && isIndexable(prop)) {
    value = value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s) => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [...parentScopes, ...rootScopes];
  const set2 = new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (defined(fallback) && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [""], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target;
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (defined(value)) {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (defined(value)) {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
var EPSILON = Number.EPSILON || 1e-14;
var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t2) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t2 * s01;
  const fb = t2 * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle = (element) => window.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle(el).getPropertyValue(property);
}
var positions = ["top", "right", "bottom", "left"];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(evt, canvas) {
  const e = evt.native || evt;
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return { x, y, box };
}
function getRelativePosition(evt, chart) {
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(evt, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = deviceHeight / pixelRatio;
  chart.width = deviceWidth / pixelRatio;
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener("test", null, options);
    window.removeEventListener("test", null, options);
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t2, mode) {
  return {
    x: p1.x + t2 * (p2.x - p1.x),
    y: p1.y + t2 * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t2, mode) {
  return {
    x: p1.x + t2 * (p2.x - p1.x),
    y: mode === "middle" ? t2 < 0.5 ? p1.y : p2.y : mode === "after" ? t2 < 1 ? p1.y : p2.y : t2 > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t2, mode) {
  const cp1 = { x: p1.cp2x, y: p1.cp2y };
  const cp2 = { x: p2.cp1x, y: p2.cp1y };
  const a = _pointInLine(p1, cp1, t2);
  const b = _pointInLine(cp1, cp2, t2);
  const c = _pointInLine(cp2, p2, t2);
  const d = _pointInLine(a, b, t2);
  const e = _pointInLine(b, c, t2);
  return _pointInLine(d, e, t2);
}
var intlCache = new Map();
function getNumberFormat(locale2, options) {
  options = options || {};
  const cacheKey = locale2 + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale2, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale2, options) {
  return getNumberFormat(locale2, options).format(num);
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: (x) => x
  };
}
function normalizeSegment({ start, end, count, loop, style }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property);
  const count = points.length;
  let { start, end, loop } = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return { start, end, loop, style: segment.style };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [segment];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({ start: subStart, end: i, loop, count, style }));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({ start: subStart, end, loop, count, style }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return { start, end };
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({ start: start % count, end: (end - 1) % count, loop });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({ start: start % count, end: last % count, loop });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [{ start, end, loop }], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({ start: s % count, end: e % count, loop: l, style: st });
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
}

// node_modules/chart.js/dist/chart.esm.js
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw2 = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw2 = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from, to, factor) {
    return factor > 0.5 ? to : from;
  },
  color(from, to, factor) {
    const c0 = color(from || transparent);
    const c1 = c0.valid && color(to || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
  },
  number(from, to, factor) {
    return from + (to - from) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to) {
    const currentValue = target[prop];
    to = resolve([cfg.to, to, currentValue, cfg.from]);
    const from = resolve([cfg.from, currentValue, to]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from;
    this._to = to;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([cfg.to, to, currentValue, cfg.from]);
      this._from = resolve([cfg.from, currentValue, to]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from = this._from;
    const loop = this._loop;
    const to = this._to;
    let factor;
    this._active = from !== to && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from, to, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({ res, rej });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
};
var numbers = ["x", "y", "borderWidth", "radius", "tension"];
var colors = ["color", "borderColor", "backgroundColor"];
defaults.set("animation", {
  delay: void 0,
  duration: 1e3,
  easing: "easeOutQuart",
  fn: void 0,
  from: void 0,
  loop: void 0,
  to: void 0,
  type: void 0
});
var animationOptions = Object.keys(defaults.animation);
defaults.describe("animation", {
  _fallback: false,
  _indexable: false,
  _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
});
defaults.set("animations", {
  colors: {
    type: "color",
    properties: colors
  },
  numbers: {
    type: "number",
    properties: numbers
  }
});
defaults.describe("animations", {
  _fallback: "animation"
});
defaults.set("transitions", {
  active: {
    animation: {
      duration: 400
    }
  },
  resize: {
    animation: {
      duration: 0
    }
  },
  show: {
    animations: {
      colors: {
        from: "transparent"
      },
      visible: {
        type: "boolean",
        duration: 0
      }
    }
  },
  hide: {
    animations: {
      colors: {
        to: "transparent"
      },
      visible: {
        type: "boolean",
        easing: "linear",
        fn: (v) => v | 0
      }
    }
  }
});
var Animations = class {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, { $shared: false, $animations: {} });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t2, r, b, l;
  if (isObject(value)) {
    t2 = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t2 = r = b = l = value;
  }
  return {
    top: t2,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
  }
}
function getFirstScaleId(chart, axis) {
  const scales = chart.scales;
  return Object.keys(scales).filter((key) => scales[key].axis === axis).shift();
}
function createDatasetContext(parent, index) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index,
    index,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index,
    parsed: void 0,
    raw: void 0,
    element,
    index,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && { keys: getSortedDatasetIndices(chart, true), values: null };
var DatasetController = class {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.$context = void 0;
    this._syncList = [];
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index], index),
        [vAxis]: vScale.parse(data[index], index)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(item[0], index),
        y: yScale.parse(item[1], index)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
      };
    }
    return parsed;
  }
  getParsed(index) {
    return this._cachedMeta._parsed[index];
  }
  getDataElement(index) {
    return this._cachedMeta.data[index];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]
    };
    return applyStack(stack, value, meta.index, { mode });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index, active) {
    const mode = active ? "active" : "default";
    return index === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
  }
  getContext(index, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index >= 0 && index < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
      context.parsed = this.getParsed(index);
      context.raw = dataset.data[index];
      context.index = context.dataIndex = index;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index);
  }
  _resolveElementOptions(elementType, mode = "default", index) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index, active);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  updateElement(element, index, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index, mode, active) {
    element.active = active;
    const options = this.getStyle(index, active);
    this._resolveAnimations(index, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, "active", false);
  }
  setHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([this.index, ...args]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync(["_insertElements", this.getDataset().data.length - count, count]);
  }
  _onDataPop() {
    this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
  }
  _onDataShift() {
    this._sync(["_removeElements", 0, 1]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync(["_removeElements", start, count]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync(["_insertElements", start, newCount]);
    }
  }
  _onDataUnshift() {
    this._sync(["_insertElements", 0, arguments.length]);
  }
};
DatasetController.defaults = {};
DatasetController.prototype.datasetElementType = null;
DatasetController.prototype.dataElementType = null;
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index] - size / 2
  };
}
function computeFlexCategoryTraits(index, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index];
  let prev = index > 0 ? pixels[index - 1] : null;
  let next = index < pixels.length - 1 ? pixels[index + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return { start, end, reverse, top, bottom };
}
function setBorderSkipped(properties, options, stack, index) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index) {
      edge = top;
    } else if ((stack._bottom || 0) === index) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = class extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset2 = mode === "reset";
    const { index, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset2 || isNullOrUndef(parsed[vScale.axis]) ? { base, head: base } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const metasets = iScale.getMatchingVisibleMetas(this._type);
    const stacked = iScale.options.stacked;
    const ilen = metasets.length;
    const stacks = [];
    let i, item;
    for (i = 0; i < ilen; ++i) {
      item = metasets[i];
      if (!item.controller.options.grouped) {
        continue;
      }
      if (typeof dataIndex !== "undefined") {
        const val = item.controller.getParsed(dataIndex)[item.controller._cachedMeta.vScale.axis];
        if (isNullOrUndef(val) || isNaN(val)) {
          continue;
        }
      }
      if (stacked === false || stacks.indexOf(item.stack) === -1 || stacked === void 0 && item.stack === void 0) {
        stacks.push(item.stack);
      }
      if (item.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index) {
    return this._getStacks(void 0, index).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index = name !== void 0 ? stacks.indexOf(name) : -1;
    return index === -1 ? stacks.length - 1 : index;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index) {
    const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      head = base + size;
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
      const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : void 0);
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }
};
BarController.id = "bar";
BarController.defaults = {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "base", "width", "height"]
    }
  }
};
BarController.overrides = {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
};
var BubbleController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: meta.label,
      value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset2 = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset2 && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset2 ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset2 ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
        if (reset2) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  resolveDataElementOptions(index, mode) {
    const parsed = this.getParsed(index);
    let values = super.resolveDataElementOptions(index, mode);
    if (values.$shared) {
      values = Object.assign({}, values, { $shared: false });
    }
    const radius = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
};
BubbleController.id = "bubble";
BubbleController.defaults = {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "borderWidth", "radius"]
    }
  }
};
BubbleController.overrides = {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        }
      }
    }
  }
};
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return { ratioX, ratioY, offsetX, offsetY };
}
var DoughnutController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i2) => +data[i2];
      if (isObject(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data[i2], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset2) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset2 && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset2 = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset2 && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset2);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset2);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index], chart.options.locale);
    return {
      label: labels[index] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
DoughnutController.id = "doughnut";
DoughnutController.defaults = {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
};
DoughnutController.descriptors = {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing"
};
DoughnutController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(tooltipItem) {
          let dataLabel = tooltipItem.label;
          const value = ": " + tooltipItem.formattedValue;
          if (isArray(dataLabel)) {
            dataLabel = dataLabel.slice();
            dataLabel[0] += value;
          } else {
            dataLabel += value;
          }
          return dataLabel;
        }
      }
    }
  }
};
var LineController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset2 = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset2 || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset2 || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && parsed[iAxis] - prevParsed[iAxis] > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
};
LineController.id = "line";
LineController.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
};
LineController.overrides = {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
};
function getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, _parsed } = meta;
    const axis = iScale.axis;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1), start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return { start, count };
}
function scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
var PolarAreaController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index].r, chart.options.locale);
    return {
      label: labels[index] || "",
      value
    };
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset2 = mode === "reset";
    const chart = this.chart;
    const dataset = this.getDataset();
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;
      angle = endAngle;
      if (reset2) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const dataset = this.getDataset();
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index) => {
      if (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index, mode, defaultAngle) {
    return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
  }
};
PolarAreaController.id = "polarArea";
PolarAreaController.defaults = {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
    }
  },
  indexAxis: "r",
  startAngle: 0
};
PolarAreaController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(context) {
          return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
        }
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
};
var PieController = class extends DoughnutController {
};
PieController.id = "pie";
PieController.defaults = {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
};
var RadarController = class extends DatasetController {
  getLabelAndValue(index) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: vScale.getLabels()[index],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const dataset = this.getDataset();
    const scale = this._cachedMeta.rScale;
    const reset2 = mode === "reset";
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);
      const x = reset2 ? scale.xCenter : pointPosition.x;
      const y = reset2 ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
};
RadarController.id = "radar";
RadarController.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
};
RadarController.overrides = {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
};
var ScatterController = class extends LineController {
};
ScatterController.id = "scatter";
ScatterController.defaults = {
  showLine: false,
  fill: false
};
ScatterController.overrides = {
  interaction: {
    mode: "point"
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(item) {
          return "(" + item.label + ", " + item.formattedValue + ")";
        }
      }
    }
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
};
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapter = class {
  constructor(options) {
    this.options = options || {};
  }
  formats() {
    return abstract();
  }
  parse(value, format) {
    return abstract();
  }
  format(timestamp, format) {
    return abstract();
  }
  add(timestamp, amount, unit) {
    return abstract();
  }
  diff(a, b, unit) {
    return abstract();
  }
  startOf(timestamp, unit, weekday) {
    return abstract();
  }
  endOf(timestamp, unit) {
    return abstract();
  }
};
DateAdapter.override = function(members) {
  Object.assign(DateAdapter.prototype, members);
};
var adapters = {
  _date: DateAdapter
};
function getRelativePosition2(e, chart) {
  if ("native" in e) {
    return {
      x: e.x,
      y: e.y
    };
  }
  return getRelativePosition(e, chart);
}
function evaluateAllVisibleItems(chart, handler) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  let index, data, element;
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    ({ index, data } = metasets[i]);
    for (let j = 0, jlen = data.length; j < jlen; ++j) {
      element = data[j];
      if (!element.skip) {
        handler(element, index, j);
      }
    }
  }
}
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return { lo: start.lo, hi: end.hi };
      }
    }
  }
  return { lo: 0, hi: data.length - 1 };
}
function optimizedEvaluateItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index, data } = metasets[i];
    const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition) {
  const items = [];
  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index) {
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({ element, datasetIndex, index });
    }
  };
  optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index) {
    const { startAngle, endAngle } = element.getProps(["startAngle", "endAngle"], useFinalPosition);
    const { angle } = getAngleFromPoint(element, { x: position.x, y: position.y });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({ element, datasetIndex, index });
    }
  }
  optimizedEvaluateItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = _isPointInArea(center, chart.chartArea, chart._minPadding);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [{ element, datasetIndex, index }];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({ element, datasetIndex, index });
    }
  }
  optimizedEvaluateItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition) {
  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition);
}
function getAxisItems(chart, e, options, useFinalPosition) {
  const position = getRelativePosition2(e, chart);
  const items = [];
  const axis = options.axis;
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateAllVisibleItems(chart, (element, datasetIndex, index) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({ element, datasetIndex, index });
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      intersectsItem = true;
    }
  });
  if (options.intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition2(e, chart);
      const axis = options.axis || "x";
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);
      const elements = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index = items[0].index;
        const element = meta.data[index];
        if (element && !element.skip) {
          elements.push({ element, datasetIndex: meta.index, index });
        }
      });
      return elements;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition2(e, chart);
      const axis = options.axis || "xy";
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({ element: data[i], datasetIndex, index: i });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition2(e, chart);
      const axis = options.axis || "xy";
      return getIntersectItems(chart, position, axis, useFinalPosition);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition2(e, chart);
      const axis = options.axis || "xy";
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition);
    },
    x(chart, e, options, useFinalPosition) {
      return getAxisItems(chart, e, { axis: "x", intersect: options.intersect }, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      return getAxisItems(chart, e, { axis: "y", intersect: options.intersect }, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = ["left", "top", "right", "bottom"];
function filterByPosition(array, position) {
  return array.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || { size: 0, count: 1 };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = { left: 0, top: 0, right: 0, bottom: 0 };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
defaults.set("layout", {
  autoPadding: true,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
});
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [{
        z: 0,
        draw(chartArea) {
          item.draw(chartArea);
        }
      }];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index !== -1) {
      chart.boxes.splice(index, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, { left: 0, top: 0, right: 0, bottom: 0 });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, { childList: true, subtree: true });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, { childList: true, subtree: true });
  return observer;
}
var drpListeningCharts = new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart, (args) => {
    const event = args[0];
    return [event, event.offsetX, event.offsetY];
  });
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    ["height", "width"].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var Element = class {
  constructor() {
    this.x = void 0;
    this.y = void 0;
    this.active = false;
    this.options = void 0;
    this.$animations = void 0;
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return { x, y };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
Element.defaults = {};
Element.defaultRoutes = void 0;
var formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale2 = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale2, options);
  },
  logarithmic(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if (remain === 1 || remain === 2 || remain === 5) {
      return formatters.numeric.call(this, tickValue, index, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = { formatters };
defaults.set("scale", {
  display: true,
  offset: false,
  reverse: false,
  beginAtZero: false,
  bounds: "ticks",
  grace: 0,
  grid: {
    display: true,
    lineWidth: 1,
    drawBorder: true,
    drawOnChartArea: true,
    drawTicks: true,
    tickLength: 8,
    tickWidth: (_ctx, options) => options.lineWidth,
    tickColor: (_ctx, options) => options.color,
    offset: false,
    borderDash: [],
    borderDashOffset: 0,
    borderWidth: 1
  },
  title: {
    display: false,
    text: "",
    padding: {
      top: 4,
      bottom: 4
    }
  },
  ticks: {
    minRotation: 0,
    maxRotation: 50,
    mirror: false,
    textStrokeWidth: 0,
    textStrokeColor: "",
    padding: 3,
    display: true,
    autoSkip: true,
    autoSkipPadding: 3,
    labelOffset: 0,
    callback: Ticks.formatters.values,
    minor: {},
    major: {},
    align: "center",
    crossAlign: "near",
    showLabelBackdrop: false,
    backdropColor: "rgba(255, 255, 255, 0.75)",
    backdropPadding: 2
  }
});
defaults.route("scale.ticks", "color", "", "color");
defaults.route("scale.grid", "color", "", "borderColor");
defaults.route("scale.grid", "borderColor", "", "borderColor");
defaults.route("scale.title", "color", "", "color");
defaults.describe("scale", {
  _fallback: false,
  _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
  _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash"
});
defaults.describe("scales", {
  _fallback: "scale"
});
defaults.describe("scale.ticks", {
  _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
  _indexable: (name) => name !== "backdropPadding"
});
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index, tick) {
  return createContext(parent, {
    tick,
    index,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return { titleX, titleY, maxWidth, rotation };
}
var Scale = class extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return { min, max };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [this]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [this]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [this]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [this]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [this]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [this]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [this]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [this]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = this.ticks.length;
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [this]);
  }
  beforeFit() {
    callback(this.options.beforeFit, [this]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [this]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; ++i) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || { data: {}, gc: [] };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index) {
    const ticks = this.ticks || [];
    if (index >= 0 && index < ticks.length) {
      const tick = ticks[index];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h4 = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h4 * cos > w * sin ? w / cos : h4 / sin : h4 * sin < w * cos ? h4 / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const optsAtIndex = grid.setContext(this.getContext(i));
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = grid.borderDash || [];
      const borderDashOffset = optsAtIndex.borderDashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      if (isHorizontal) {
        x = pixel;
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = y + textOffset - labelPadding.top;
        let left = x - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        rotation,
        label,
        font,
        color: color2,
        strokeColor,
        strokeWidth,
        textOffset,
        textAlign,
        textBaseline,
        translation: [x, y],
        backdrop
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return { textAlign, x };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return { top: 0, left: this.left, bottom: chart.height, right: this.right };
    }
    if (position === "top" || position === "bottom") {
      return { top: this.top, left: 0, bottom: this.bottom, right: chart.width };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index = ticks.findIndex((t2) => t2.value === value);
    if (index >= 0) {
      const opts = grid.setContext(this.getContext(index));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine({ x: item.x1, y: item.y1 }, { x: item.x2, y: item.y2 }, item);
        }
        if (grid.drawTicks) {
          drawLine({ x: item.tx1, y: item.ty1 }, { x: item.tx2, y: item.ty2 }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { grid } } = this;
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.borderWidth;
    ctx.strokeStyle = borderOpts.borderColor;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    let i, ilen;
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      const item = items[i];
      const tickFont = item.font;
      const label = item.label;
      if (item.backdrop) {
        ctx.fillStyle = item.backdrop.color;
        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
      }
      let y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, item);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [titleX, titleY]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [{
        z: tz,
        draw: (chartArea) => {
          this.draw(chartArea);
        }
      }];
    }
    return [{
      z: gz,
      draw: (chartArea) => {
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawTitle();
      }
    }, {
      z: gz + 1,
      draw: () => {
        this.drawBorder();
      }
    }, {
      z: tz,
      draw: (chartArea) => {
        this.drawLabels(chartArea);
      }
    }];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index) {
    const opts = this.options.ticks.setContext(this.getContext(index));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [scope].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [this.controllers, this.scales, this.elements];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [...args].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = new Registry();
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [chart, args, descriptor.options];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
};
function allPlugins(config) {
  const plugins = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins.indexOf(plugin) === -1) {
      plugins.push(plugin);
    }
  }
  return plugins;
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, plugins, options, all) {
  const result = [];
  const context = chart.getContext();
  for (let i = 0; i < plugins.length; i++) {
    const plugin = plugins[i];
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, plugin, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, plugin, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  return config.createResolver(scopes, context, [""], { scriptable: false, indexable: false, allKeys: true });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, scaleOptions) {
  if (id === "x" || id === "y") {
    return id;
  }
  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || { scales: {} };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const firstIDs = Object.create(null);
  const scales = Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    firstIDs[axis] = firstIDs[axis] || id;
    scales[id] = mergeIf(Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
      scales[id] = scales[id] || Object.create(null);
      mergeIf(scales[id], [{ axis }, configScales[id], defaultScaleOptions[defaultID]]);
    });
  });
  Object.keys(scales).forEach((key) => {
    const scale = scales[key];
    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
  });
  return scales;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = new Map();
var keysCached = new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
var addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = new Map();
    this._resolverCache = new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [[
      `datasets.${datasetType}`,
      ""
    ]]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [[
      `datasets.${datasetType}.elements.${elementType}`,
      `datasets.${datasetType}`,
      `elements.${elementType}`,
      ""
    ]]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [[
      `plugins.${id}`,
      ...plugin.additionalOptionScopes || []
    ]]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      { type },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
    const result = { $shared: true };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "3.7.1";
var KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions2 = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions2 && animationOptions2.onComplete, [context], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions2 = chart.options.animation;
  callback(animationOptions2 && animationOptions2.onProgress, [context], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
var Chart = class {
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = { width, height };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", { size: newSize });
    callback(options.onResize, [this, newSize], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales = this.scales;
    const updated = Object.keys(scales).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales && scales[id].type === scaleType) {
        scale = scales[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales[id];
      }
    });
    each(scales, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index) => {
      if (datasets.filter((x) => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass.prototype, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset2 = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset2);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", { mode });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({ method: a[1], start: +a[2], count: +a[3] }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index) => {
      item._idx = index;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction(mode) ? mode({ datasetIndex: i }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", { mode });
  }
  _updateDataset(index, mode) {
    const meta = this.getDatasetMeta(index);
    const args = { meta, index, mode, cancelable: true };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({ chart: this });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = this.chartArea;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, { chart: this, type: "chart" }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index) {
    this._hiddenIndices[index] = !this._hiddenIndices[index];
  }
  getDataVisibility(index) {
    return !this._hiddenIndices[index];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, { visible });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    this.notifyPlugins("destroy");
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: _isPointInArea(e, this.chartArea, this._minPadding)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [e, active, this], this);
      if (isClick) {
        callback(options.onClick, [e, active, this], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
var invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());
var enumerable = true;
Object.defineProperties(Chart, {
  defaults: {
    enumerable,
    value: defaults
  },
  instances: {
    enumerable,
    value: instances
  },
  overrides: {
    enumerable,
    value: overrides
  },
  registry: {
    enumerable,
    value: registry
  },
  version: {
    enumerable,
    value: version
  },
  getChart: {
    enumerable,
    value: getChart
  },
  register: {
    enumerable,
    value: (...items) => {
      registry.add(...items);
      invalidatePlugins();
    }
  },
  unregister: {
    enumerable,
    value: (...items) => {
      registry.remove(...items);
      invalidatePlugins();
    }
  }
});
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset, spacing, end) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
    spacingOffset = (alpha - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
  if (outerEnd > 0) {
    const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
  }
  const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
  ctx.lineTo(p4.x, p4.y);
  if (innerEnd > 0) {
    const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
  }
  ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
  if (innerStart > 0) {
    const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
  }
  const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
  ctx.lineTo(p8.x, p8.y);
  if (outerStart > 0) {
    const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, startAngle + TAU);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + circumference % TAU;
      if (circumference % TAU === 0) {
        endAngle += TAU;
      }
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle);
  ctx.fill();
  return endAngle;
}
function drawFullCircleBorders(ctx, element, inner) {
  const { x, y, startAngle, pixelMargin, fullCircles } = element;
  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
  const innerRadius = element.innerRadius + pixelMargin;
  let i;
  if (inner) {
    clipArc(ctx, element, startAngle + TAU);
  }
  ctx.beginPath();
  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
}
function drawBorder(ctx, element, offset, spacing, endAngle) {
  const { options } = element;
  const { borderWidth, borderJoinStyle } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  if (element.fullCircles) {
    drawFullCircleBorders(ctx, element, inner);
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  pathArc(ctx, element, offset, spacing, endAngle);
  ctx.stroke();
}
var ArcElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps(["x", "y"], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, { x: chartX, y: chartY });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = this.options.spacing / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 2;
    const spacing = (options.spacing || 0) / 2;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    let radiusOffset = 0;
    if (offset) {
      radiusOffset = offset / 2;
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
      if (this.circumference >= PI) {
        radiusOffset = offset;
      }
    }
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    const endAngle = drawArc(ctx, this, radiusOffset, spacing);
    drawBorder(ctx, this, radiusOffset, spacing, endAngle);
    ctx.restore();
  }
};
ArcElement.id = "arc";
ArcElement.defaults = {
  borderAlign: "center",
  borderColor: "#fff",
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0
};
ArcElement.defaultRoutes = {
  backgroundColor: "backgroundColor"
};
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, { start, end: start + count - 1 })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
var usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
var LineElement = class extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, { property, start: value, end: value });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const { start, end } = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t2 = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t2, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, { start, end: start + count - 1 });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
};
LineElement.id = "line";
LineElement.defaults = {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
};
LineElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
LineElement.descriptors = {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
};
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([axis], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
var PointElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return { x, y };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
};
PointElement.id = "point";
PointElement.defaults = {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
};
PointElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return { left, top, right, bottom };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h4 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h4,
    radius: rect.radius
  };
}
var BarElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
BarElement.id = "bar";
BarElement.defaults = {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
};
BarElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
var Legend = class extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [0];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = { left: 0, top, row, width: itemWidth, height: itemHeight };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({ width: currentColWidth, height: currentColHeight });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = { left, top: currentColHeight, col, width: itemWidth, height: itemHeight };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({ width: currentColWidth, height: currentColHeight });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { color: fontColor, padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxWidth * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor || fontColor;
      ctx.fillStyle = legendItem.fontColor || fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [e, previous, this], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [e, hoveredItem, this], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [e, hoveredItem, this], this);
    }
  }
};
function isListened(type, opts) {
  if (type === "mousemove" && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({ ctx: chart.ctx, options, chart });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index)) {
        ci.hide(index);
        legendItem.hidden = true;
      } else {
        ci.show(index);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2 } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: 0,
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => !["generateLabels", "filter", "sort"].includes(name)
    }
  }
};
var Title = class extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return { titleX, titleY, maxWidth, rotation };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [titleX, titleY]
    });
  }
};
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var map2 = new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map2.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map2.get(chart));
    map2.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map2.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let x = 0;
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }
    return {
      x: x / count,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index);
  return {
    chart,
    label,
    parsed: controller.getParsed(index),
    raw: chart.data.datasets[datasetIndex].data[index],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return { width, height };
}
function determineYAlign(chart, size) {
  const { y, height } = size;
  if (y < height / 2) {
    return "top";
  } else if (y > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width } = size;
  if (xAlign === "right") {
    x -= width;
  } else if (xAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var Tooltip = class extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart || config._chart;
    this._chart = this.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
    const title = callbacks.title.apply(this, [context]);
    const afterTitle = callbacks.afterTitle.apply(this, [context]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
    const footer = callbacks.footer.apply(this, [tooltipItems]);
    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(scoped.labelColor.call(this, context));
      labelPointStyles.push(scoped.labelPointStyle.call(this, context));
      labelTextColors.push(scoped.labelTextColor.call(this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, { chart: this.chart, tooltip: this, replay });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return { x1, x2, x3, y1, y2, y3 };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColors = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColors.borderColor;
      ctx.fillStyle = labelColors.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = labelColors.borderWidth || 1;
      ctx.strokeStyle = labelColors.borderColor;
      ctx.setLineDash(labelColors.borderDash || []);
      ctx.lineDashOffset = labelColors.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
      const borderRadius = toTRBLCorners(labelColors.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
Tooltip.positioners = positioners;
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({ chart, options });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    const args = {
      tooltip
    };
    if (chart.notifyPlugins("beforeTooltipDraw", args) === false) {
      return;
    }
    if (tooltip) {
      tooltip.draw(chart.ctx);
    }
    chart.notifyPlugins("afterTooltipDraw", args);
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "width", "height", "caretX", "caretY"]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: {
      beforeTitle: noop,
      title(tooltipItems) {
        if (tooltipItems.length > 0) {
          const item = tooltipItems[0];
          const labels = item.chart.data.labels;
          const labelCount = labels ? labels.length : 0;
          if (this && this.options && this.options.mode === "dataset") {
            return item.dataset.label || "";
          } else if (item.label) {
            return item.label;
          } else if (labelCount > 0 && item.dataIndex < labelCount) {
            return labels[item.dataIndex];
          }
        }
        return "";
      },
      afterTitle: noop,
      beforeBody: noop,
      beforeLabel: noop,
      label(tooltipItem) {
        if (this && this.options && this.options.mode === "dataset") {
          return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
        }
        let label = tooltipItem.dataset.label || "";
        if (label) {
          label += ": ";
        }
        const value = tooltipItem.formattedValue;
        if (!isNullOrUndef(value)) {
          label += value;
        }
        return label;
      },
      labelColor(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          borderColor: options.borderColor,
          backgroundColor: options.backgroundColor,
          borderWidth: options.borderWidth,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderRadius: 0
        };
      },
      labelTextColor() {
        return this.options.bodyColor;
      },
      labelPointStyle(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          pointStyle: options.pointStyle,
          rotation: options.rotation
        };
      },
      afterLabel: noop,
      afterBody: noop,
      beforeFooter: noop,
      footer: noop,
      afterFooter: noop
    }
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: ["interaction"]
};
var addIfString = (labels, raw, index, addedLabels) => {
  if (typeof raw === "string") {
    index = labels.push(raw) - 1;
    addedLabels.unshift({ index, label: raw });
  } else if (isNaN(raw)) {
    index = null;
  }
  return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index : first;
}
var validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);
var CategoryScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index, label } of added) {
        if (labels[index] === label) {
          labels.splice(index, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
    return validIndex(index, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({ value });
    }
    return ticks;
  }
  getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
CategoryScale.id = "category";
CategoryScale.defaults = {
  ticks: {
    callback: CategoryScale.prototype.getLabelForValue
  }
};
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [{ value: rmin }, { value: rmax }];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({ value: min });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    ticks.push({ value: Math.round((niceMin + j * spacing) * factor) / factor });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({ value: max });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({ value: niceMax });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = 1;
      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
        offset = Math.abs(max * 0.05);
      }
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
LinearScale.id = "linear";
LinearScale.defaults = {
  ticks: {
    callback: Ticks.formatters.numeric
  }
};
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
  return remain === 1;
}
function generateTicks(generationOptions, dataRange) {
  const endExp = Math.floor(log10(dataRange.max));
  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
  const ticks = [];
  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
  let exp = Math.floor(log10(tickVal));
  let significand = Math.floor(tickVal / Math.pow(10, exp));
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  do {
    ticks.push({ value: tickVal, major: isMajor(tickVal) });
    ++significand;
    if (significand === 10) {
      significand = 1;
      ++exp;
      precision = exp >= 0 ? 1 : precision;
    }
    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
  } while (exp < endExp || exp === endExp && significand < endSignificand);
  const lastTick = finiteOrDefault(generationOptions.max, tickVal);
  ticks.push({ value: lastTick, major: isMajor(tickVal) });
  return ticks;
}
var LogarithmicScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(exp(min, -1));
        setMax(exp(max, 1));
      }
    }
    if (min <= 0) {
      setMin(exp(max, -1));
    }
    if (max <= 0) {
      setMax(exp(min, 1));
    }
    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
      setMin(exp(min, -1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
LogarithmicScale.id = "logarithmic";
LogarithmicScale.defaults = {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
};
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [label];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const extra = getTickBackdropHeight(opts) / 2;
  const outerDistance = scale.drawingArea;
  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const size = labelSizes[i];
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    items.push({
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    });
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h4, angle) {
  if (angle === 90 || angle === 270) {
    y -= h4 / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h4;
  }
  return y;
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];
    const { backdropColor } = optsAtIndex;
    if (!isNullOrUndef(backdropColor)) {
      const padding = toPadding(optsAtIndex.backdropPadding);
      ctx.fillStyle = backdropColor;
      ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);
    }
    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(gridLineOpts.borderDash);
  ctx.lineDashOffset = gridLineOpts.borderDashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index, label) {
  return createContext(parent, {
    label,
    index,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h4 = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h4 / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h4) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index) => {
      const label = callback(this.options.pointLabels.callback, [value, index], this);
      return label || label === 0 ? label : "";
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index) {
    const pointLabels = this._pointLabels || [];
    if (index >= 0 && index < pointLabels.length) {
      const pointLabel = pointLabels[index];
      return createPointLabelContext(this.getContext(), index, pointLabel);
    }
  }
  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index, value) {
    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index) {
    return this.getPointPositionForValue(index || 0, this.getBaseValue());
  }
  getPointLabelPosition(index) {
    const { left, top, right, bottom } = this._pointLabelItems[index];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index) => {
        if (index !== 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const optsAtIndex = grid.setContext(this.getContext(index - 1));
          drawRadiusLine(this, optsAtIndex, offset, labelCount);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index) => {
      if (index === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
RadialLinearScale.id = "radialLinear";
RadialLinearScale.defaults = {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
};
RadialLinearScale.defaultRoutes = {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
};
RadialLinearScale.descriptors = {
  angleLines: {
    _fallback: "grid"
  }
};
var INTERVALS = {
  millisecond: { common: true, size: 1, steps: 1e3 },
  second: { common: true, size: 1e3, steps: 60 },
  minute: { common: true, size: 6e4, steps: 60 },
  hour: { common: true, size: 36e5, steps: 24 },
  day: { common: true, size: 864e5, steps: 30 },
  week: { common: false, size: 6048e5, steps: 4 },
  month: { common: true, size: 2628e6, steps: 12 },
  quarter: { common: false, size: 7884e6, steps: 4 },
  year: { common: true, size: 3154e7 }
};
var UNITS = Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map3, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index = map3[major];
    if (index >= 0) {
      ticks[index].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map3 = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map3[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return { min, max };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  initOffsets(timestamps) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = { start, end, factor: 1 / (start + 1 + end) };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(timeOpts.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  _tickFormatFunction(time, index, ticks, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index];
    const major = majorUnit && majorFormat && tick && tick.major;
    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    const formatter = options.ticks.callback;
    return formatter ? callback(formatter, [label, index, ticks], this) : label;
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
TimeScale.id = "time";
TimeScale.defaults = {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    major: {
      enabled: false
    }
  }
};
function interpolate2(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate2(table, this.min);
    this._tableRange = interpolate2(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        { time: min, pos: 0 },
        { time: max, pos: 1 }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({ time: curr, pos: i / (ilen - 1) });
      }
    }
    return table;
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
TimeSeriesScale.id = "timeseries";
TimeSeriesScale.defaults = TimeScale.defaults;

// src/stats-modal.tsx
Chart.register(BarElement, BarController, plugin_legend, plugin_title, plugin_tooltip, plugin_subtitle, CategoryScale, LinearScale, PieController, ArcElement);
var StatsModal = class extends import_obsidian4.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.titleEl.setText(`${t("STATS_TITLE")} `);
    this.titleEl.innerHTML += /* @__PURE__ */ (0, import_vhtml3.default)("select", {
      id: "chartPeriod"
    }, /* @__PURE__ */ (0, import_vhtml3.default)("option", {
      value: "month",
      selected: true
    }, t("MONTH")), /* @__PURE__ */ (0, import_vhtml3.default)("option", {
      value: "quarter"
    }, t("QUARTER")), /* @__PURE__ */ (0, import_vhtml3.default)("option", {
      value: "year"
    }, t("YEAR")), /* @__PURE__ */ (0, import_vhtml3.default)("option", {
      value: "lifetime"
    }, t("LIFETIME")));
    this.modalEl.style.height = "100%";
    this.modalEl.style.width = "100%";
    if (import_obsidian4.Platform.isMobile) {
      this.contentEl.style.display = "block";
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.style.textAlign = "center";
    let maxN = Math.max(...getKeysPreserveType(this.plugin.dueDatesFlashcards));
    for (let dueOffset = 0; dueOffset <= maxN; dueOffset++) {
      if (!Object.prototype.hasOwnProperty.call(this.plugin.dueDatesFlashcards, dueOffset)) {
        this.plugin.dueDatesFlashcards[dueOffset] = 0;
      }
    }
    const dueDatesFlashcardsCopy = { 0: 0 };
    for (const [dueOffset, dueCount] of Object.entries(this.plugin.dueDatesFlashcards)) {
      if (dueOffset <= 0) {
        dueDatesFlashcardsCopy[0] += dueCount;
      } else {
        dueDatesFlashcardsCopy[dueOffset] = dueCount;
      }
    }
    const cardStats = this.plugin.cardStats;
    const scheduledCount = cardStats.youngCount + cardStats.matureCount;
    maxN = Math.max(maxN, 1);
    contentEl.innerHTML += /* @__PURE__ */ (0, import_vhtml3.default)("div", null, /* @__PURE__ */ (0, import_vhtml3.default)("canvas", {
      id: "forecastChart"
    }), /* @__PURE__ */ (0, import_vhtml3.default)("span", {
      id: "forecastChartSummary"
    }), /* @__PURE__ */ (0, import_vhtml3.default)("p", null), /* @__PURE__ */ (0, import_vhtml3.default)("canvas", {
      id: "intervalsChart"
    }), /* @__PURE__ */ (0, import_vhtml3.default)("span", {
      id: "intervalsChartSummary"
    }), /* @__PURE__ */ (0, import_vhtml3.default)("p", null), /* @__PURE__ */ (0, import_vhtml3.default)("canvas", {
      id: "easesChart"
    }), /* @__PURE__ */ (0, import_vhtml3.default)("span", {
      id: "easesChartSummary"
    }), /* @__PURE__ */ (0, import_vhtml3.default)("p", null), /* @__PURE__ */ (0, import_vhtml3.default)("div", {
      style: "width: 50%; margin: auto;"
    }, /* @__PURE__ */ (0, import_vhtml3.default)("canvas", {
      id: "cardTypesChart"
    })), /* @__PURE__ */ (0, import_vhtml3.default)("span", {
      id: "cardTypesChartSummary"
    }));
    createStatsChart("bar", "forecastChart", t("FORECAST"), t("FORECAST_DESC"), Object.keys(dueDatesFlashcardsCopy), Object.values(dueDatesFlashcardsCopy), t("REVIEWS_PER_DAY", { avg: (scheduledCount / maxN).toFixed(1) }), t("SCHEDULED"), t("DAYS"), t("NUMBER_OF_CARDS"));
    maxN = Math.max(...getKeysPreserveType(cardStats.intervals));
    for (let interval = 0; interval <= maxN; interval++) {
      if (!Object.prototype.hasOwnProperty.call(cardStats.intervals, interval)) {
        cardStats.intervals[interval] = 0;
      }
    }
    const average_interval = textInterval(Math.round(Object.entries(cardStats.intervals).map(([interval, count]) => interval * count).reduce((a, b) => a + b, 0) / scheduledCount * 10) / 10 || 0, false), longest_interval = textInterval(Math.max(...getKeysPreserveType(cardStats.intervals)) || 0, false);
    createStatsChart("bar", "intervalsChart", t("INTERVALS"), t("INTERVALS_DESC"), Object.keys(cardStats.intervals), Object.values(cardStats.intervals), t("INTERVALS_SUMMARY", { avg: average_interval, longest: longest_interval }), t("COUNT"), t("DAYS"), t("NUMBER_OF_CARDS"));
    const eases = getKeysPreserveType(cardStats.eases);
    for (let ease = Math.min(...eases); ease <= Math.max(...eases); ease++) {
      if (!Object.prototype.hasOwnProperty.call(cardStats.eases, ease)) {
        cardStats.eases[ease] = 0;
      }
    }
    const average_ease = Math.round(Object.entries(cardStats.eases).map(([ease, count]) => ease * count).reduce((a, b) => a + b, 0) / scheduledCount) || 0;
    createStatsChart("bar", "easesChart", t("EASES"), "", Object.keys(cardStats.eases), Object.values(cardStats.eases), t("EASES_SUMMARY", { avgEase: average_ease }), t("COUNT"), t("EASES"), t("NUMBER_OF_CARDS"));
    const totalCardsCount = this.plugin.deckTree.totalFlashcards;
    createStatsChart("pie", "cardTypesChart", t("CARD_TYPES"), t("CARD_TYPES_DESC"), [
      `${t("CARD_TYPE_NEW")} - ${Math.round(cardStats.newCount / totalCardsCount * 100)}%`,
      `${t("CARD_TYPE_YOUNG")} - ${Math.round(cardStats.youngCount / totalCardsCount * 100)}%`,
      `${t("CARD_TYPE_MATURE")} - ${Math.round(cardStats.matureCount / totalCardsCount * 100)}%`
    ], [cardStats.newCount, cardStats.youngCount, cardStats.matureCount], t("CARD_TYPES_SUMMARY", { totalCardsCount }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
function createStatsChart(type, canvasId, title, subtitle, labels, data, summary, seriesTitle = "", xAxisTitle = "", yAxisTitle = "") {
  let scales = {}, backgroundColor = ["#2196f3"];
  if (type !== "pie") {
    scales = {
      x: {
        title: {
          display: true,
          text: xAxisTitle
        }
      },
      y: {
        title: {
          display: true,
          text: yAxisTitle
        }
      }
    };
  } else {
    backgroundColor = ["#2196f3", "#4caf50", "green"];
  }
  const shouldFilter = canvasId === "forecastChart" || canvasId === "intervalsChart";
  const statsChart = new Chart(document.getElementById(canvasId), {
    type,
    data: {
      labels: shouldFilter ? labels.slice(0, 31) : labels,
      datasets: [
        {
          label: seriesTitle,
          backgroundColor,
          data: shouldFilter ? data.slice(0, 31) : data
        }
      ]
    },
    options: {
      scales,
      plugins: {
        title: {
          display: true,
          text: title,
          font: {
            size: 22
          }
        },
        subtitle: {
          display: true,
          text: subtitle,
          font: {
            size: 16
          }
        },
        legend: {
          display: false
        }
      }
    }
  });
  if (shouldFilter) {
    const chartPeriodEl = document.getElementById("chartPeriod");
    chartPeriodEl.addEventListener("click", () => {
      let filteredLabels, filteredData;
      const chartPeriod = chartPeriodEl.value;
      if (chartPeriod === "month") {
        filteredLabels = labels.slice(0, 31);
        filteredData = data.slice(0, 31);
      } else if (chartPeriod === "quarter") {
        filteredLabels = labels.slice(0, 91);
        filteredData = data.slice(0, 91);
      } else if (chartPeriod === "year") {
        filteredLabels = labels.slice(0, 366);
        filteredData = data.slice(0, 366);
      } else {
        filteredLabels = labels;
        filteredData = data;
      }
      statsChart.data.labels = filteredLabels;
      statsChart.data.datasets[0] = {
        label: seriesTitle,
        backgroundColor,
        data: filteredData
      };
      statsChart.update();
    });
  }
  document.getElementById(`${canvasId}Summary`).innerText = summary;
}

// src/sidebar.ts
var import_obsidian5 = __toModule(require("obsidian"));
var REVIEW_QUEUE_VIEW_TYPE = "review-queue-list-view";
var ReviewQueueListView = class extends import_obsidian5.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.registerEvent(this.app.workspace.on("file-open", () => this.redraw()));
    this.registerEvent(this.app.vault.on("rename", () => this.redraw()));
  }
  getViewType() {
    return REVIEW_QUEUE_VIEW_TYPE;
  }
  getDisplayText() {
    return t("NOTES_REVIEW_QUEUE");
  }
  getIcon() {
    return "SpacedRepIcon";
  }
  onHeaderMenu(menu) {
    menu.addItem((item) => {
      item.setTitle(t("CLOSE")).setIcon("cross").onClick(() => {
        this.app.workspace.detachLeavesOfType(REVIEW_QUEUE_VIEW_TYPE);
      });
    });
  }
  redraw() {
    const activeFile = this.app.workspace.getActiveFile();
    const rootEl = createDiv("nav-folder mod-root");
    const childrenEl = rootEl.createDiv("nav-folder-children");
    for (const deckKey in this.plugin.reviewDecks) {
      const deck = this.plugin.reviewDecks[deckKey];
      const deckCollapsed = !deck.activeFolders.has(deck.deckName);
      const deckFolderEl = this.createRightPaneFolder(childrenEl, deckKey, deckCollapsed, false, deck).getElementsByClassName("nav-folder-children")[0];
      if (deck.newNotes.length > 0) {
        const newNotesFolderEl = this.createRightPaneFolder(deckFolderEl, t("NEW"), !deck.activeFolders.has(t("NEW")), deckCollapsed, deck);
        for (const newFile of deck.newNotes) {
          const fileIsOpen = activeFile && newFile.path === activeFile.path;
          if (fileIsOpen) {
            deck.activeFolders.add(deck.deckName);
            deck.activeFolders.add(t("NEW"));
            this.changeFolderIconToExpanded(newNotesFolderEl);
            this.changeFolderIconToExpanded(deckFolderEl);
          }
          this.createRightPaneFile(newNotesFolderEl, newFile, fileIsOpen, !deck.activeFolders.has(t("NEW")), deck, this.plugin);
        }
      }
      if (deck.scheduledNotes.length > 0) {
        const now = Date.now();
        let currUnix = -1;
        let schedFolderEl = null, folderTitle = "";
        const maxDaysToRender = this.plugin.data.settings.maxNDaysNotesReviewQueue;
        for (const sNote of deck.scheduledNotes) {
          if (sNote.dueUnix != currUnix) {
            const nDays = Math.ceil((sNote.dueUnix - now) / (24 * 3600 * 1e3));
            if (nDays > maxDaysToRender) {
              break;
            }
            if (nDays === -1) {
              folderTitle = t("YESTERDAY");
            } else if (nDays === 0) {
              folderTitle = t("TODAY");
            } else if (nDays === 1) {
              folderTitle = t("TOMORROW");
            } else {
              folderTitle = new Date(sNote.dueUnix).toDateString();
            }
            schedFolderEl = this.createRightPaneFolder(deckFolderEl, folderTitle, !deck.activeFolders.has(folderTitle), deckCollapsed, deck);
            currUnix = sNote.dueUnix;
          }
          const fileIsOpen = activeFile && sNote.note.path === activeFile.path;
          if (fileIsOpen) {
            deck.activeFolders.add(deck.deckName);
            deck.activeFolders.add(folderTitle);
            this.changeFolderIconToExpanded(schedFolderEl);
            this.changeFolderIconToExpanded(deckFolderEl);
          }
          this.createRightPaneFile(schedFolderEl, sNote.note, fileIsOpen, !deck.activeFolders.has(folderTitle), deck, this.plugin);
        }
      }
    }
    const contentEl = this.containerEl.children[1];
    contentEl.empty();
    contentEl.appendChild(rootEl);
  }
  createRightPaneFolder(parentEl, folderTitle, collapsed, hidden, deck) {
    const folderEl = parentEl.createDiv("nav-folder");
    const folderTitleEl = folderEl.createDiv("nav-folder-title");
    const childrenEl = folderEl.createDiv("nav-folder-children");
    const collapseIconEl = folderTitleEl.createDiv("nav-folder-collapse-indicator collapse-icon");
    collapseIconEl.innerHTML = COLLAPSE_ICON;
    if (collapsed) {
      collapseIconEl.childNodes[0].style.transform = "rotate(-90deg)";
    }
    folderTitleEl.createDiv("nav-folder-title-content").setText(folderTitle);
    if (hidden) {
      folderEl.style.display = "none";
    }
    folderTitleEl.onClickEvent(() => {
      for (const child of childrenEl.childNodes) {
        if (child.style.display === "block" || child.style.display === "") {
          child.style.display = "none";
          collapseIconEl.childNodes[0].style.transform = "rotate(-90deg)";
          deck.activeFolders.delete(folderTitle);
        } else {
          child.style.display = "block";
          collapseIconEl.childNodes[0].style.transform = "";
          deck.activeFolders.add(folderTitle);
        }
      }
    });
    return folderEl;
  }
  createRightPaneFile(folderEl, file, fileElActive, hidden, deck, plugin) {
    const navFileEl = folderEl.getElementsByClassName("nav-folder-children")[0].createDiv("nav-file");
    if (hidden) {
      navFileEl.style.display = "none";
    }
    const navFileTitle = navFileEl.createDiv("nav-file-title");
    if (fileElActive) {
      navFileTitle.addClass("is-active");
    }
    navFileTitle.createDiv("nav-file-title-content").setText(file.basename);
    navFileTitle.addEventListener("click", (event) => {
      event.preventDefault();
      plugin.lastSelectedReviewDeck = deck.deckName;
      this.app.workspace.activeLeaf.openFile(file);
      return false;
    }, false);
    navFileTitle.addEventListener("contextmenu", (event) => {
      event.preventDefault();
      const fileMenu = new import_obsidian5.Menu(this.app);
      this.app.workspace.trigger("file-menu", fileMenu, file, "my-context-menu", null);
      fileMenu.showAtPosition({
        x: event.pageX,
        y: event.pageY
      });
      return false;
    }, false);
  }
  changeFolderIconToExpanded(folderEl) {
    const collapseIconEl = folderEl.find("div.nav-folder-collapse-indicator");
    collapseIconEl.childNodes[0].style.transform = "";
  }
};

// src/review-deck.ts
var import_obsidian6 = __toModule(require("obsidian"));
var ReviewDeck = class {
  constructor(name) {
    this.newNotes = [];
    this.scheduledNotes = [];
    this.dueNotesCount = 0;
    this.deckName = name;
    this.activeFolders = new Set([this.deckName, t("TODAY")]);
  }
  sortNotes(pageranks) {
    this.newNotes = this.newNotes.sort((a, b) => (pageranks[b.path] || 0) - (pageranks[a.path] || 0));
    this.scheduledNotes = this.scheduledNotes.sort((a, b) => {
      const result = a.dueUnix - b.dueUnix;
      if (result != 0) {
        return result;
      }
      return (pageranks[b.note.path] || 0) - (pageranks[a.note.path] || 0);
    });
  }
};
var ReviewDeckSelectionModal = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app, deckKeys) {
    super(app);
    this.deckKeys = [];
    this.deckKeys = deckKeys;
  }
  getItems() {
    return this.deckKeys;
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(deckKey, _) {
    this.close();
    this.submitCallback(deckKey);
  }
};

// src/parser.ts
function parse2(text, singlelineCardSeparator, singlelineReversedCardSeparator, multilineCardSeparator, multilineReversedCardSeparator, convertHighlightsToClozes, convertBoldTextToClozes) {
  let cardText = "";
  const cards = [];
  let cardType = null;
  let lineNo = 0;
  const lines = text.split("\n");
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].length === 0) {
      if (cardType) {
        cards.push([cardType, cardText, lineNo]);
        cardType = null;
      }
      cardText = "";
      continue;
    } else if (lines[i].startsWith("<!--") && !lines[i].startsWith("<!--SR:")) {
      while (i + 1 < lines.length && !lines[i].includes("-->"))
        i++;
      i++;
      continue;
    }
    if (cardText.length > 0) {
      cardText += "\n";
    }
    cardText += lines[i];
    if (lines[i].includes(singlelineReversedCardSeparator) || lines[i].includes(singlelineCardSeparator)) {
      cardType = lines[i].includes(singlelineReversedCardSeparator) ? CardType.SingleLineReversed : CardType.SingleLineBasic;
      cardText = lines[i];
      lineNo = i;
      if (i + 1 < lines.length && lines[i + 1].startsWith("<!--SR:")) {
        cardText += "\n" + lines[i + 1];
        i++;
      }
      cards.push([cardType, cardText, lineNo]);
      cardType = null;
      cardText = "";
    } else if (cardType === null && (convertHighlightsToClozes && /==.*?==/gm.test(lines[i]) || convertBoldTextToClozes && /\*\*.*?\*\*/gm.test(lines[i]))) {
      cardType = CardType.Cloze;
      lineNo = i;
    } else if (lines[i] === multilineCardSeparator) {
      cardType = CardType.MultiLineBasic;
      lineNo = i;
    } else if (lines[i] === multilineReversedCardSeparator) {
      cardType = CardType.MultiLineReversed;
      lineNo = i;
    } else if (lines[i].startsWith("```")) {
      while (i + 1 < lines.length && !lines[i + 1].startsWith("```")) {
        i++;
        cardText += "\n" + lines[i];
      }
      cardText += "\n```";
      i++;
    }
  }
  if (cardType && cardText) {
    cards.push([cardType, cardText, lineNo]);
  }
  return cards;
}

// src/icons/appicon.ts
var import_obsidian7 = __toModule(require("obsidian"));
function appIcon() {
  (0, import_obsidian7.addIcon)("SpacedRepIcon", `<path fill="currentColor" stroke="currentColor" d="M 88.960938 17.257812 L 47.457031 17.257812 C 45.679688 17.257812 44.230469 18.703125 44.230469 20.484375 L 44.230469 86.558594 C 44.230469 88.335938 45.679688 89.785156 47.457031 89.785156 L 88.960938 89.785156 C 90.738281 89.785156 92.1875 88.335938 92.1875 86.558594 L 92.1875 20.484375 C 92.1875 18.703125 90.738281 17.257812 88.960938 17.257812 Z M 88.28125 85.878906 L 48.136719 85.878906 L 48.136719 21.164062 L 88.28125 21.164062 Z M 88.28125 85.878906 "/>
        <path fill="currentColor" stroke="currentColor"  d="M 88.960938 9.445312 L 61.667969 9.445312 C 59.925781 3.816406 54.011719 0.515625 48.269531 2.054688 L 8.183594 12.796875 C 2.304688 14.371094 -1.199219 20.4375 0.378906 26.316406 L 17.476562 90.140625 C 18.796875 95.066406 23.269531 98.324219 28.144531 98.324219 C 29.085938 98.324219 30.046875 98.199219 31 97.945312 L 40.765625 95.328125 C 42.625 96.75 44.941406 97.597656 47.457031 97.597656 L 88.960938 97.597656 C 95.046875 97.597656 100 92.644531 100 86.558594 L 100 20.484375 C 100 14.398438 95.046875 9.445312 88.960938 9.445312 Z M 29.988281 94.171875 C 26.1875 95.191406 22.269531 92.925781 21.25 89.128906 L 4.152344 25.304688 C 3.132812 21.507812 5.394531 17.585938 9.195312 16.570312 L 49.28125 5.828125 C 52.578125 4.945312 55.960938 6.53125 57.464844 9.445312 L 47.457031 9.445312 C 41.371094 9.445312 36.417969 14.398438 36.417969 20.484375 L 36.417969 86.558594 C 36.417969 88.558594 36.957031 90.433594 37.890625 92.054688 Z M 96.09375 86.558594 C 96.09375 90.492188 92.894531 93.691406 88.960938 93.691406 L 47.457031 93.691406 C 43.523438 93.691406 40.324219 90.492188 40.324219 86.558594 L 40.324219 20.484375 C 40.324219 16.550781 43.523438 13.351562 47.457031 13.351562 L 88.960938 13.351562 C 92.894531 13.351562 96.09375 16.550781 96.09375 20.484375 Z M 96.09375 86.558594 "/>
        <path fill="currentColor" stroke="currentColor"  d="M 54.101562 53.09375 L 60.070312 57.410156 L 57.789062 64.378906 C 56.90625 67.074219 59.996094 69.320312 62.285156 67.648438 L 68.210938 63.324219 L 74.132812 67.648438 C 76.421875 69.320312 79.511719 67.074219 78.628906 64.378906 L 76.347656 57.410156 L 82.320312 53.09375 C 84.613281 51.433594 83.441406 47.804688 80.605469 47.804688 L 73.242188 47.804688 L 70.988281 40.839844 C 70.117188 38.144531 66.300781 38.144531 65.429688 40.839844 L 63.179688 47.804688 L 55.8125 47.804688 C 52.980469 47.804688 51.804688 51.433594 54.101562 53.09375 Z M 54.101562 53.09375 "/>
        `);
}

// src/main.ts
var DEFAULT_DATA = {
  settings: DEFAULT_SETTINGS,
  buryDate: "",
  buryList: []
};
var SRPlugin = class extends import_obsidian8.Plugin {
  constructor() {
    super(...arguments);
    this.syncLock = false;
    this.reviewDecks = {};
    this.newNotes = [];
    this.scheduledNotes = [];
    this.easeByPath = {};
    this.incomingLinks = {};
    this.pageranks = {};
    this.dueNotesCount = 0;
    this.dueDatesNotes = {};
    this.deckTree = new Deck("root", null);
    this.dueDatesFlashcards = {};
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadPluginData();
      appIcon();
      this.statusBar = this.addStatusBarItem();
      this.statusBar.classList.add("mod-clickable");
      this.statusBar.setAttribute("aria-label", t("OPEN_NOTE_FOR_REVIEW"));
      this.statusBar.setAttribute("aria-label-position", "top");
      this.statusBar.addEventListener("click", () => __async(this, null, function* () {
        if (!this.syncLock) {
          yield this.sync();
          this.reviewNextNoteModal();
        }
      }));
      this.addRibbonIcon("SpacedRepIcon", t("REVIEW_CARDS"), () => __async(this, null, function* () {
        if (!this.syncLock) {
          yield this.sync();
          new FlashcardModal(this.app, this).open();
        }
      }));
      this.registerView(REVIEW_QUEUE_VIEW_TYPE, (leaf) => this.reviewQueueView = new ReviewQueueListView(leaf, this));
      if (!this.data.settings.disableFileMenuReviewOptions) {
        this.registerEvent(this.app.workspace.on("file-menu", (menu, fileish) => {
          if (fileish instanceof import_obsidian8.TFile && fileish.extension === "md") {
            menu.addItem((item) => {
              item.setTitle(t("REVIEW_EASY_FILE_MENU")).setIcon("SpacedRepIcon").onClick(() => {
                this.saveReviewResponse(fileish, ReviewResponse.Easy);
              });
            });
            menu.addItem((item) => {
              item.setTitle(t("REVIEW_GOOD_FILE_MENU")).setIcon("SpacedRepIcon").onClick(() => {
                this.saveReviewResponse(fileish, ReviewResponse.Good);
              });
            });
            menu.addItem((item) => {
              item.setTitle(t("REVIEW_HARD_FILE_MENU")).setIcon("SpacedRepIcon").onClick(() => {
                this.saveReviewResponse(fileish, ReviewResponse.Hard);
              });
            });
          }
        }));
      }
      this.addCommand({
        id: "srs-note-review-open-note",
        name: t("OPEN_NOTE_FOR_REVIEW"),
        callback: () => __async(this, null, function* () {
          if (!this.syncLock) {
            yield this.sync();
            this.reviewNextNoteModal();
          }
        })
      });
      this.addCommand({
        id: "srs-note-review-easy",
        name: t("REVIEW_NOTE_EASY_CMD"),
        callback: () => {
          const openFile = this.app.workspace.getActiveFile();
          if (openFile && openFile.extension === "md") {
            this.saveReviewResponse(openFile, ReviewResponse.Easy);
          }
        }
      });
      this.addCommand({
        id: "srs-note-review-good",
        name: t("REVIEW_NOTE_GOOD_CMD"),
        callback: () => {
          const openFile = this.app.workspace.getActiveFile();
          if (openFile && openFile.extension === "md") {
            this.saveReviewResponse(openFile, ReviewResponse.Good);
          }
        }
      });
      this.addCommand({
        id: "srs-note-review-hard",
        name: t("REVIEW_NOTE_HARD_CMD"),
        callback: () => {
          const openFile = this.app.workspace.getActiveFile();
          if (openFile && openFile.extension === "md") {
            this.saveReviewResponse(openFile, ReviewResponse.Hard);
          }
        }
      });
      this.addCommand({
        id: "srs-review-flashcards",
        name: t("REVIEW_ALL_CARDS"),
        callback: () => __async(this, null, function* () {
          if (!this.syncLock) {
            yield this.sync();
            new FlashcardModal(this.app, this).open();
          }
        })
      });
      this.addCommand({
        id: "srs-review-flashcards-in-note",
        name: t("REVIEW_CARDS_IN_NOTE"),
        callback: () => __async(this, null, function* () {
          const openFile = this.app.workspace.getActiveFile();
          if (openFile && openFile.extension === "md") {
            this.deckTree = new Deck("root", null);
            const deckPath = this.findDeckPath(openFile);
            yield this.findFlashcardsInNote(openFile, deckPath);
            new FlashcardModal(this.app, this).open();
          }
        })
      });
      this.addCommand({
        id: "srs-cram-flashcards-in-note",
        name: t("CRAM_CARDS_IN_NOTE"),
        callback: () => __async(this, null, function* () {
          const openFile = this.app.workspace.getActiveFile();
          if (openFile && openFile.extension === "md") {
            this.deckTree = new Deck("root", null);
            const deckPath = this.findDeckPath(openFile);
            yield this.findFlashcardsInNote(openFile, deckPath, false, true);
            new FlashcardModal(this.app, this, true).open();
          }
        })
      });
      this.addCommand({
        id: "srs-view-stats",
        name: t("VIEW_STATS"),
        callback: () => __async(this, null, function* () {
          if (!this.syncLock) {
            yield this.sync();
            new StatsModal(this.app, this).open();
          }
        })
      });
      this.addSettingTab(new SRSettingTab(this.app, this));
      this.app.workspace.onLayoutReady(() => {
        this.initView();
        setTimeout(() => __async(this, null, function* () {
          if (!this.syncLock) {
            yield this.sync();
          }
        }), 2e3);
      });
    });
  }
  onunload() {
    this.app.workspace.getLeavesOfType(REVIEW_QUEUE_VIEW_TYPE).forEach((leaf) => leaf.detach());
  }
  sync() {
    return __async(this, null, function* () {
      if (this.syncLock) {
        return;
      }
      this.syncLock = true;
      graph.reset();
      this.easeByPath = {};
      this.incomingLinks = {};
      this.pageranks = {};
      this.dueNotesCount = 0;
      this.dueDatesNotes = {};
      this.reviewDecks = {};
      this.deckTree = new Deck("root", null);
      this.dueDatesFlashcards = {};
      this.cardStats = {
        eases: {},
        intervals: {},
        newCount: 0,
        youngCount: 0,
        matureCount: 0
      };
      const now = window.moment(Date.now());
      const todayDate = now.format("YYYY-MM-DD");
      if (todayDate !== this.data.buryDate) {
        this.data.buryDate = todayDate;
        this.data.buryList = [];
      }
      const notes = this.app.vault.getMarkdownFiles();
      for (const note of notes) {
        if (this.data.settings.noteFoldersToIgnore.some((folder) => note.path.startsWith(folder))) {
          continue;
        }
        if (this.incomingLinks[note.path] === void 0) {
          this.incomingLinks[note.path] = [];
        }
        const links = this.app.metadataCache.resolvedLinks[note.path] || {};
        for (const targetPath in links) {
          if (this.incomingLinks[targetPath] === void 0)
            this.incomingLinks[targetPath] = [];
          if (targetPath.split(".").pop().toLowerCase() === "md") {
            this.incomingLinks[targetPath].push({
              sourcePath: note.path,
              linkCount: links[targetPath]
            });
            graph.link(note.path, targetPath, links[targetPath]);
          }
        }
        const deckPath = this.findDeckPath(note);
        if (deckPath.length !== 0) {
          const flashcardsInNoteAvgEase = yield this.findFlashcardsInNote(note, deckPath);
          if (flashcardsInNoteAvgEase > 0) {
            this.easeByPath[note.path] = flashcardsInNoteAvgEase;
          }
        }
        const fileCachedData = this.app.metadataCache.getFileCache(note) || {};
        const frontmatter = fileCachedData.frontmatter || {};
        const tags = (0, import_obsidian8.getAllTags)(fileCachedData) || [];
        let shouldIgnore = true;
        const matchedNoteTags = [];
        for (const tagToReview of this.data.settings.tagsToReview) {
          if (tags.some((tag) => tag === tagToReview || tag.startsWith(tagToReview + "/"))) {
            if (!Object.prototype.hasOwnProperty.call(this.reviewDecks, tagToReview)) {
              this.reviewDecks[tagToReview] = new ReviewDeck(tagToReview);
            }
            matchedNoteTags.push(tagToReview);
            shouldIgnore = false;
            break;
          }
        }
        if (shouldIgnore) {
          continue;
        }
        if (!(Object.prototype.hasOwnProperty.call(frontmatter, "sr-due") && Object.prototype.hasOwnProperty.call(frontmatter, "sr-interval") && Object.prototype.hasOwnProperty.call(frontmatter, "sr-ease"))) {
          for (const matchedNoteTag of matchedNoteTags) {
            this.reviewDecks[matchedNoteTag].newNotes.push(note);
          }
          continue;
        }
        const dueUnix = window.moment(frontmatter["sr-due"], ["YYYY-MM-DD", "DD-MM-YYYY", "ddd MMM DD YYYY"]).valueOf();
        for (const matchedNoteTag of matchedNoteTags) {
          this.reviewDecks[matchedNoteTag].scheduledNotes.push({ note, dueUnix });
          if (dueUnix <= now.valueOf()) {
            this.reviewDecks[matchedNoteTag].dueNotesCount++;
          }
        }
        if (Object.prototype.hasOwnProperty.call(this.easeByPath, note.path)) {
          this.easeByPath[note.path] = (this.easeByPath[note.path] + frontmatter["sr-ease"]) / 2;
        } else {
          this.easeByPath[note.path] = frontmatter["sr-ease"];
        }
        if (dueUnix <= now.valueOf()) {
          this.dueNotesCount++;
        }
        const nDays = Math.ceil((dueUnix - now.valueOf()) / (24 * 3600 * 1e3));
        if (!Object.prototype.hasOwnProperty.call(this.dueDatesNotes, nDays)) {
          this.dueDatesNotes[nDays] = 0;
        }
        this.dueDatesNotes[nDays]++;
      }
      graph.rank(0.85, 1e-6, (node, rank2) => {
        this.pageranks[node] = rank2 * 1e4;
      });
      this.deckTree.sortSubdecksList();
      if (this.data.settings.showDebugMessages) {
        console.log(`SR: ${t("EASES")}`, this.easeByPath);
        console.log(`SR: ${t("DECKS")}`, this.deckTree);
      }
      for (const deckKey in this.reviewDecks) {
        this.reviewDecks[deckKey].sortNotes(this.pageranks);
      }
      if (this.data.settings.showDebugMessages) {
        console.log("SR: " + t("SYNC_TIME_TAKEN", {
          t: Date.now() - now.valueOf()
        }));
      }
      this.statusBar.setText(t("STATUS_BAR", {
        dueNotesCount: this.dueNotesCount,
        dueFlashcardsCount: this.deckTree.dueFlashcardsCount
      }));
      this.reviewQueueView.redraw();
      this.syncLock = false;
    });
  }
  saveReviewResponse(note, response) {
    return __async(this, null, function* () {
      const fileCachedData = this.app.metadataCache.getFileCache(note) || {};
      const frontmatter = fileCachedData.frontmatter || {};
      const tags = (0, import_obsidian8.getAllTags)(fileCachedData) || [];
      if (this.data.settings.noteFoldersToIgnore.some((folder) => note.path.startsWith(folder))) {
        new import_obsidian8.Notice(t("NOTE_IN_IGNORED_FOLDER"));
        return;
      }
      let shouldIgnore = true;
      for (const tag of tags) {
        if (this.data.settings.tagsToReview.some((tagToReview) => tag === tagToReview || tag.startsWith(tagToReview + "/"))) {
          shouldIgnore = false;
          break;
        }
      }
      if (shouldIgnore) {
        new import_obsidian8.Notice(t("PLEASE_TAG_NOTE"));
        return;
      }
      let fileText = yield this.app.vault.read(note);
      let ease, interval, delayBeforeReview;
      const now = Date.now();
      if (!(Object.prototype.hasOwnProperty.call(frontmatter, "sr-due") && Object.prototype.hasOwnProperty.call(frontmatter, "sr-interval") && Object.prototype.hasOwnProperty.call(frontmatter, "sr-ease"))) {
        let linkTotal = 0, linkPGTotal = 0, totalLinkCount = 0;
        for (const statObj of this.incomingLinks[note.path] || []) {
          const ease2 = this.easeByPath[statObj.sourcePath];
          if (ease2) {
            linkTotal += statObj.linkCount * this.pageranks[statObj.sourcePath] * ease2;
            linkPGTotal += this.pageranks[statObj.sourcePath] * statObj.linkCount;
            totalLinkCount += statObj.linkCount;
          }
        }
        const outgoingLinks = this.app.metadataCache.resolvedLinks[note.path] || {};
        for (const linkedFilePath in outgoingLinks) {
          const ease2 = this.easeByPath[linkedFilePath];
          if (ease2) {
            linkTotal += outgoingLinks[linkedFilePath] * this.pageranks[linkedFilePath] * ease2;
            linkPGTotal += this.pageranks[linkedFilePath] * outgoingLinks[linkedFilePath];
            totalLinkCount += outgoingLinks[linkedFilePath];
          }
        }
        const linkContribution = this.data.settings.maxLinkFactor * Math.min(1, Math.log(totalLinkCount + 0.5) / Math.log(64));
        ease = (1 - linkContribution) * this.data.settings.baseEase + (totalLinkCount > 0 ? linkContribution * linkTotal / linkPGTotal : linkContribution * this.data.settings.baseEase);
        if (Object.prototype.hasOwnProperty.call(this.easeByPath, note.path)) {
          ease = (ease + this.easeByPath[note.path]) / 2;
        }
        ease = Math.round(ease);
        interval = 1;
        delayBeforeReview = 0;
      } else {
        interval = frontmatter["sr-interval"];
        ease = frontmatter["sr-ease"];
        delayBeforeReview = now - window.moment(frontmatter["sr-due"], ["YYYY-MM-DD", "DD-MM-YYYY", "ddd MMM DD YYYY"]).valueOf();
      }
      const schedObj = schedule(response, interval, ease, delayBeforeReview, this.data.settings, this.dueDatesNotes);
      interval = schedObj.interval;
      ease = schedObj.ease;
      const due = window.moment(now + interval * 24 * 3600 * 1e3);
      const dueString = due.format("YYYY-MM-DD");
      if (SCHEDULING_INFO_REGEX.test(fileText)) {
        const schedulingInfo = SCHEDULING_INFO_REGEX.exec(fileText);
        fileText = fileText.replace(SCHEDULING_INFO_REGEX, `---
${schedulingInfo[1]}sr-due: ${dueString}
sr-interval: ${interval}
sr-ease: ${ease}
${schedulingInfo[5]}---`);
      } else if (YAML_FRONT_MATTER_REGEX.test(fileText)) {
        const existingYaml = YAML_FRONT_MATTER_REGEX.exec(fileText);
        fileText = fileText.replace(YAML_FRONT_MATTER_REGEX, `---
${existingYaml[1]}sr-due: ${dueString}
sr-interval: ${interval}
sr-ease: ${ease}
---`);
      } else {
        fileText = `---
sr-due: ${dueString}
sr-interval: ${interval}
sr-ease: ${ease}
---

${fileText}`;
      }
      if (this.data.settings.burySiblingCards) {
        yield this.findFlashcardsInNote(note, [], true);
        yield this.savePluginData();
      }
      yield this.app.vault.modify(note, fileText);
      new import_obsidian8.Notice(t("RESPONSE_RECEIVED"));
      yield this.sync();
      if (this.data.settings.autoNextNote) {
        this.reviewNextNote(this.lastSelectedReviewDeck);
      }
    });
  }
  reviewNextNoteModal() {
    return __async(this, null, function* () {
      const reviewDeckNames = Object.keys(this.reviewDecks);
      if (reviewDeckNames.length === 1) {
        this.reviewNextNote(reviewDeckNames[0]);
      } else {
        const deckSelectionModal = new ReviewDeckSelectionModal(this.app, reviewDeckNames);
        deckSelectionModal.submitCallback = (deckKey) => this.reviewNextNote(deckKey);
        deckSelectionModal.open();
      }
    });
  }
  reviewNextNote(deckKey) {
    return __async(this, null, function* () {
      if (!Object.prototype.hasOwnProperty.call(this.reviewDecks, deckKey)) {
        new import_obsidian8.Notice(t("NO_DECK_EXISTS", { deckName: deckKey }));
        return;
      }
      this.lastSelectedReviewDeck = deckKey;
      const deck = this.reviewDecks[deckKey];
      if (deck.dueNotesCount > 0) {
        const index = this.data.settings.openRandomNote ? Math.floor(Math.random() * deck.dueNotesCount) : 0;
        this.app.workspace.activeLeaf.openFile(deck.scheduledNotes[index].note);
        return;
      }
      if (deck.newNotes.length > 0) {
        const index = this.data.settings.openRandomNote ? Math.floor(Math.random() * deck.newNotes.length) : 0;
        this.app.workspace.activeLeaf.openFile(deck.newNotes[index]);
        return;
      }
      new import_obsidian8.Notice(t("ALL_CAUGHT_UP"));
    });
  }
  findDeckPath(note) {
    let deckPath = [];
    if (this.data.settings.convertFoldersToDecks) {
      deckPath = note.path.split("/");
      deckPath.pop();
      if (deckPath.length === 0) {
        deckPath = ["/"];
      }
    } else {
      const fileCachedData = this.app.metadataCache.getFileCache(note) || {};
      const tags = (0, import_obsidian8.getAllTags)(fileCachedData) || [];
      outer:
        for (const tagToReview of this.data.settings.flashcardTags) {
          for (const tag of tags) {
            if (tag === tagToReview || tag.startsWith(tagToReview + "/")) {
              deckPath = tag.substring(1).split("/");
              break outer;
            }
          }
        }
    }
    return deckPath;
  }
  findFlashcardsInNote(note, deckPath, buryOnly = false, ignoreStats = false) {
    return __async(this, null, function* () {
      var _a;
      let fileText = yield this.app.vault.read(note);
      const fileCachedData = this.app.metadataCache.getFileCache(note) || {};
      const headings = fileCachedData.headings || [];
      let fileChanged = false, totalNoteEase = 0, scheduledCount = 0;
      const settings = this.data.settings;
      const noteDeckPath = deckPath;
      const now = Date.now();
      const parsedCards = parse2(fileText, settings.singlelineCardSeparator, settings.singlelineReversedCardSeparator, settings.multilineCardSeparator, settings.multilineReversedCardSeparator, settings.convertHighlightsToClozes, settings.convertBoldTextToClozes);
      for (const parsedCard of parsedCards) {
        deckPath = noteDeckPath;
        const cardType = parsedCard[0], lineNo = parsedCard[2];
        let cardText = parsedCard[1];
        if (!settings.convertFoldersToDecks) {
          const tagInCardRegEx = /^#[^\s#]+/gi;
          const cardDeckPath = (_a = cardText.match(tagInCardRegEx)) == null ? void 0 : _a.slice(-1)[0].replace("#", "").split("/");
          if (cardDeckPath) {
            deckPath = cardDeckPath;
            cardText = cardText.replaceAll(tagInCardRegEx, "");
          }
        }
        this.deckTree.createDeck([...deckPath]);
        const cardTextHash = cyrb53(cardText);
        if (buryOnly) {
          this.data.buryList.push(cardTextHash);
          continue;
        }
        const siblingMatches = [];
        if (cardType === CardType.Cloze) {
          const siblings2 = [];
          if (settings.convertHighlightsToClozes) {
            siblings2.push(...cardText.matchAll(/==(.*?)==/gm));
          }
          if (settings.convertBoldTextToClozes) {
            siblings2.push(...cardText.matchAll(/\*\*(.*?)\*\*/gm));
          }
          siblings2.sort((a, b) => {
            if (a.index < b.index) {
              return -1;
            }
            if (a.index > b.index) {
              return 1;
            }
            return 0;
          });
          let front, back;
          for (const m of siblings2) {
            const deletionStart = m.index, deletionEnd = deletionStart + m[0].length;
            front = cardText.substring(0, deletionStart) + "<span style='color:#2196f3'>[...]</span>" + cardText.substring(deletionEnd);
            front = front.replace(/==/gm, "").replace(/\*\*/gm, "");
            back = cardText.substring(0, deletionStart) + "<span style='color:#2196f3'>" + cardText.substring(deletionStart, deletionEnd) + "</span>" + cardText.substring(deletionEnd);
            back = back.replace(/==/gm, "").replace(/\*\*/gm, "");
            siblingMatches.push([front, back]);
          }
        } else {
          let idx;
          if (cardType === CardType.SingleLineBasic) {
            idx = cardText.indexOf(settings.singlelineCardSeparator);
            siblingMatches.push([
              cardText.substring(0, idx),
              cardText.substring(idx + settings.singlelineCardSeparator.length)
            ]);
          } else if (cardType === CardType.SingleLineReversed) {
            idx = cardText.indexOf(settings.singlelineReversedCardSeparator);
            const side1 = cardText.substring(0, idx), side2 = cardText.substring(idx + settings.singlelineReversedCardSeparator.length);
            siblingMatches.push([side1, side2]);
            siblingMatches.push([side2, side1]);
          } else if (cardType === CardType.MultiLineBasic) {
            idx = cardText.indexOf("\n" + settings.multilineCardSeparator + "\n");
            siblingMatches.push([
              cardText.substring(0, idx),
              cardText.substring(idx + 2 + settings.multilineCardSeparator.length)
            ]);
          } else if (cardType === CardType.MultiLineReversed) {
            idx = cardText.indexOf("\n" + settings.multilineReversedCardSeparator + "\n");
            const side1 = cardText.substring(0, idx), side2 = cardText.substring(idx + 2 + settings.multilineReversedCardSeparator.length);
            siblingMatches.push([side1, side2]);
            siblingMatches.push([side2, side1]);
          }
        }
        let scheduling = [...cardText.matchAll(MULTI_SCHEDULING_EXTRACTOR)];
        if (scheduling.length === 0)
          scheduling = [...cardText.matchAll(LEGACY_SCHEDULING_EXTRACTOR)];
        if (scheduling.length > siblingMatches.length) {
          const idxSched = cardText.lastIndexOf("<!--SR:") + 7;
          let newCardText = cardText.substring(0, idxSched);
          for (let i = 0; i < siblingMatches.length; i++)
            newCardText += `!${scheduling[i][1]},${scheduling[i][2]},${scheduling[i][3]}`;
          newCardText += "-->";
          const replacementRegex = new RegExp(escapeRegexString(cardText), "gm");
          fileText = fileText.replace(replacementRegex, () => newCardText);
          fileChanged = true;
        }
        const context = settings.showContextInCards ? getCardContext(lineNo, headings) : "";
        const siblings = [];
        for (let i = 0; i < siblingMatches.length; i++) {
          const front = siblingMatches[i][0].trim(), back = siblingMatches[i][1].trim();
          const cardObj = {
            isDue: i < scheduling.length,
            note,
            lineNo,
            front,
            back,
            cardText,
            context,
            cardType,
            siblingIdx: i,
            siblings
          };
          if (ignoreStats) {
            this.cardStats.newCount++;
            cardObj.isDue = true;
            this.deckTree.insertFlashcard([...deckPath], cardObj);
          } else if (i < scheduling.length) {
            const dueUnix = window.moment(scheduling[i][1], ["YYYY-MM-DD", "DD-MM-YYYY"]).valueOf();
            const nDays = Math.ceil((dueUnix - now) / (24 * 3600 * 1e3));
            if (!Object.prototype.hasOwnProperty.call(this.dueDatesFlashcards, nDays)) {
              this.dueDatesFlashcards[nDays] = 0;
            }
            this.dueDatesFlashcards[nDays]++;
            const interval = parseInt(scheduling[i][2]), ease = parseInt(scheduling[i][3]);
            if (!Object.prototype.hasOwnProperty.call(this.cardStats.intervals, interval)) {
              this.cardStats.intervals[interval] = 0;
            }
            this.cardStats.intervals[interval]++;
            if (!Object.prototype.hasOwnProperty.call(this.cardStats.eases, ease)) {
              this.cardStats.eases[ease] = 0;
            }
            this.cardStats.eases[ease]++;
            totalNoteEase += ease;
            scheduledCount++;
            if (interval >= 32) {
              this.cardStats.matureCount++;
            } else {
              this.cardStats.youngCount++;
            }
            if (this.data.buryList.includes(cardTextHash)) {
              this.deckTree.countFlashcard([...deckPath]);
              continue;
            }
            if (dueUnix <= now) {
              cardObj.interval = interval;
              cardObj.ease = ease;
              cardObj.delayBeforeReview = now - dueUnix;
              this.deckTree.insertFlashcard([...deckPath], cardObj);
            } else {
              this.deckTree.countFlashcard([...deckPath]);
              continue;
            }
          } else {
            this.cardStats.newCount++;
            if (this.data.buryList.includes(cyrb53(cardText))) {
              this.deckTree.countFlashcard([...deckPath]);
              continue;
            }
            this.deckTree.insertFlashcard([...deckPath], cardObj);
          }
          siblings.push(cardObj);
        }
      }
      if (fileChanged) {
        yield this.app.vault.modify(note, fileText);
      }
      if (scheduledCount > 0) {
        const flashcardsInNoteAvgEase = totalNoteEase / scheduledCount;
        const flashcardContribution = Math.min(1, Math.log(scheduledCount + 0.5) / Math.log(64));
        return flashcardsInNoteAvgEase * flashcardContribution + settings.baseEase * (1 - flashcardContribution);
      }
      return 0;
    });
  }
  loadPluginData() {
    return __async(this, null, function* () {
      this.data = Object.assign({}, DEFAULT_DATA, yield this.loadData());
      this.data.settings = Object.assign({}, DEFAULT_SETTINGS, this.data.settings);
    });
  }
  savePluginData() {
    return __async(this, null, function* () {
      yield this.saveData(this.data);
    });
  }
  initView() {
    if (this.app.workspace.getLeavesOfType(REVIEW_QUEUE_VIEW_TYPE).length) {
      return;
    }
    this.app.workspace.getRightLeaf(false).setViewState({
      type: REVIEW_QUEUE_VIEW_TYPE,
      active: true
    });
  }
};
function getCardContext(cardLine, headings) {
  const stack = [];
  for (const heading of headings) {
    if (heading.position.start.line > cardLine) {
      break;
    }
    while (stack.length > 0 && stack[stack.length - 1].level >= heading.level) {
      stack.pop();
    }
    stack.push(heading);
  }
  let context = "";
  for (const headingObj of stack) {
    headingObj.heading = headingObj.heading.replace(/\[\^\d+\]/gm, "").trim();
    context += headingObj.heading + " > ";
  }
  return context.slice(0, -3);
}
/*!
 * @kurkle/color v0.1.9
 * https://github.com/kurkle/color#readme
 * (c) 2020 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v3.7.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL3BhZ2VyYW5rLmpzL2xpYi9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvdmh0bWwvc3JjL2VtcHR5LXRhZ3MuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3ZodG1sL3NyYy92aHRtbC5qcyIsICIuLi9zcmMvbWFpbi50cyIsICIuLi9zcmMvc2V0dGluZ3MudHN4IiwgIi4uL3NyYy9sYW5nL2hlbHBlcnMudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2FyLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9jei50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvZGEudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2RlLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9lbi50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvZW4tZ2IudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2VzLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9mci50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvaGkudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2lkLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9pdC50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvamEudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2tvLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9ubC50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvbm8udHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3BsLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9wdC50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvcHQtYnIudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3JvLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9ydS50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvdHIudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3poLWNuLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS96aC10dy50cyIsICIuLi9zcmMvZmxhc2hjYXJkLW1vZGFsLnRzeCIsICIuLi9zcmMvc2NoZWR1bGluZy50cyIsICIuLi9zcmMvY29uc3RhbnRzLnRzIiwgIi4uL3NyYy91dGlscy50cyIsICIuLi9zcmMvc3RhdHMtbW9kYWwudHN4IiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NodW5rcy9oZWxwZXJzLnNlZ21lbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvY2hhcnQuZXNtLmpzIiwgIi4uL3NyYy9zaWRlYmFyLnRzIiwgIi4uL3NyYy9yZXZpZXctZGVjay50cyIsICIuLi9zcmMvcGFyc2VyLnRzIiwgIi4uL3NyYy9pY29ucy9hcHBpY29uLnRzIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFFQSxvQkFBZ0IsUUFBUSxXQUFVO0FBQzlCLFVBQUssT0FBTyxXQUFXLFlBQWMsT0FBTyxjQUFhLFlBQWE7QUFDbEUsaUJBQVMsT0FBTyxRQUFRO0FBQ3BCLGNBQUksT0FBTyxlQUFlLFNBQVMsTUFBTTtBQUNyQyxnQkFBSSxVQUFTLEtBQUssT0FBTyxVQUFVLE9BQU87QUFDdEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBT3BCLFlBQU8sVUFBVyxXQUFZO0FBQzFCLFVBQUksT0FBTztBQUFBLFFBQ1AsT0FBTztBQUFBLFFBQ1AsT0FBTztBQUFBLFFBQ1AsT0FBTztBQUFBO0FBR1gsV0FBSyxPQUFPLFNBQVUsUUFBUSxRQUFRLFFBQVE7QUFDMUMsWUFBSyxTQUFTLFlBQVksUUFBVSxXQUFXLE1BQU87QUFDbEQsbUJBQVM7QUFBQTtBQUdiLGlCQUFTLFdBQVc7QUFFcEIsWUFBSSxLQUFLLE1BQU0sZUFBZSxZQUFZLE1BQU07QUFDNUMsZUFBSztBQUNMLGVBQUssTUFBTSxVQUFVO0FBQUEsWUFDakIsUUFBUTtBQUFBLFlBQ1IsVUFBVTtBQUFBO0FBQUE7QUFJbEIsYUFBSyxNQUFNLFFBQVEsWUFBWTtBQUUvQixZ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RztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBO0FBRUosSUFBTSxRQUFRO0FBQUEsRUFDYixRQUFRO0FBQUEsRUFDUixhQUFhO0FBQUEsRUFDYixNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxjQUFjO0FBQUEsRUFDZCxJQUFJO0FBQUEsRUFDSixTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxhQUFhO0FBQUEsRUFDYixTQUFTO0FBQUEsRUFDVCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxXQUFXO0FBQUEsRUFDWCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixLQUFLO0FBQUEsRUFDTCxLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxTQUFTO0FBQUEsRUFDVCxRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixXQUFXO0FBQUEsRUFDWCxTQUFTO0FBQUEsRUFDVCxZQUFZO0FBQUEsRUFDWixLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxXQUFXO0FBQUEsRUFDWCxNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxZQUFZO0FBQUEsRUFDWixLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxLQUFLO0FBQUEsRUFDTCxVQUFVO0FBQUEsRUFDVixZQUFZO0FBQUEsRUFD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
