標籤: #leetcode

---

[TOC]

---

# Description

Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

A subarray is a contiguous part of an array.

- Example 1:

```
Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
Output: 6
Explanation: [4, -1, 2, 1] has the largest sum = 6.
```

- Example 2:

```
Input: nums = [1]
Output: 1
```

- Example 3:

```
Input: nums = [5, 4, -1, 7, 8]
Output: 23
```

- Constraints:
	- `1 <= nums.length <= 10^5`
	- `-104 <= nums[i] <= 104`

# Solutions

## Naive Approach $O(n^3)$

Calculating sum of subarray starting from "j" and ending at "i". Storing maximum sum.

```cpp
const int MIN_INT = -2147483648;

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int max = MIN_INT;
        int n = nums.size();
        for(int i = 0; i < n; i++)
        {
	        for(int j = 0; j <= i; j++)
	        {
		        int sum = 0;
		        for(int k = j; k <= i; k++)
		        {
			        sum += nums[k];
		        }
		        if(sum > max)
			        max = sum;
	        }
        }
        return max;
    }
};
```

## Optimized Naive Approach $O(n^2)$

Calculating pre-sum beforehand. So calculating sum in subarray becomes faster.

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int max = nums.at(0);

		for(int i = 1; i < n; i++)
		{
			nums.at(i) += nums.at(i - 1);
			if(nums.at(i) > max)
				max = nums.at(i);        // sum of array 0~i
			for(int j = 1; j <= i; j++)
			{
				int sum = nums.at(i) - nums.at(j - 1); // sum of array 
													   // j~i
				if(sum > max)
					max = sum;
			}
		}
		return max;
    }
};
```

## DP Solution $O(n)$

Using another array `dp` and dynamically build it based on array `nums` given as parameter.

- For `dp[1:n+1]`, `dp[i]` is `max(dp.at(i - 1)+num, num)`
- `max` is `max(max, dp[i])` 

For example, if the array `nums` is:

```python
[-2, 1, -3, 4, -1, 2, 1, -5, 4]
```

Then the array `dp` will be:

```python
[0, -2, 1, -2, 4, 3, 5, 6, 1, 5]
```

We can simply return the maximum in `dp`, which is `6` in this case.

- Code:

```cpp
#include <algorithm>

const int MIN_INT = -2147483648;

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
	    int n = nums.size();
        int max = MIN_INT;
        vector<int> dp(n + 1, 0); // dp.at(i) = max sum of subarray 
						          // ending at (i - 1)th index
		int i = 1;

		for(int num : nums)
		{
			dp.at(i) = std::max(dp.at(i - 1) + num, num);
			max = std::max(max, dp.at(i++));
		}

		return max;
    }
};
```

## Kadane's Algorithm $O(n)$

This is an optimization of the above [[#DP Solution O n]]. We find out that we only need `dp[i-1]` to calculate `dp[i]`. Therefore we can save space by only storing `dp[i-1]` but not the whole array `dp`.

```cpp
#include <algorithm>

const int MIN_INT = -2147483648;

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int max = MIN_INT;
        int curr = 0;

		for(int num : nums)
		{
			// dp.at(i) = std::max(dp.at(i - 1) + num, num);
			curr = std::max(curr + num, num);
			// max = std::max(max, dp.at(i++));
			max = std::max(max, curr);
		}

		return max;
    }
};
```

## Divide and Conquer Solution

```cpp
#include <algorithm>

using std::max;

class Solution
{
public:
	int maxSubArray(vector<int>& nums)
	{
		return helper(nums, 0, nums.length - 1).at(2);
	}
	static vector<int> helper(vector<int>& arr, int l, int r)
	{
		if(l == r)
			return vector<int>(4, arr.at(l));

		int mid = (l + r) / 2;

		vector<int> leftHalf = helper(arr, l, mid);
		vector<int> rightHalf = helper(arr, mid + 1, r);

		vector<int> r = {max(leftHalf[0], leftHalf[3] + rightHalf[0]),
						 max(rightHalf[1], 
						     rightHalf[3] + leftHalf[1]),
						 max(max(leftHalf[2], rightHalf[2]), 
						     leftHalf[1] + rightHalf[0]),
						 leftHalf[3] + rightHalf[3]
						};
		return r;
	}
};
```

---

參考資料:

[Maximum Subarray - leetcode](https://leetcode.com/problems/maximum-subarray/)
[Community Solution of Maximum Subarray - leetcode](https://leetcode.com/problems/maximum-subarray/discuss/1594937/Daily-LeetCoding-Challenge-November-Day-25/1160564)
[DP and Divide-and-Conquer Solution for Maximum Subarray - leetcode](https://leetcode.com/problems/maximum-subarray/discuss/20452/C++-DP-and-Divide-and-Conquer/578305)

---

link:

[[Class#Static]]